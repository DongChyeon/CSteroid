---
date: 2025-09-19
user: MatchaKim
topic: TLS 핸드쉐이킹
---

## TLS 가 뭐야?

TLS는 Transport Layer Security의 줄임말로 TCP에 보안을 얹는 프로토콜이야

HTTP랑 HTTPS의 차이라고 할 수 있지

## 차이가 뭔데?

HTTP는 평문이라 도청 위변조가 가능하고
HTTPS는 TLS로 암호화 서버인증과정을 거쳐.

브라우저는 인증서를 검증하고 합의된 키로 패킷을 암호화 해서 주고받는거야

## 인증서는 누가 발급해?

인증기관이 발급해

과정은

1. 서버 운영자가 공개키와 개인키 쌍을 생성해
2. 공개키와 도메인 정보를 넣고 CSR(Certificate Signing Request)을 만들어
3. 인증기관에 CSR을 제출하면 인증기관이 도메인의 소유권등을 검증하고 서명된 인증서를 발급해줘
4. 서버는 발급받은 인증서를 브라우저에 전달하고 인증기관의 검증에 따라 신뢰성을 보장받아

## 브라우저가 인증서를 어떻게 아는데?

크롬이나 macOS 같은 브라우저나 OS들은 미리 신뢰할 수 있는 인증서 목록을 미리 가지고있어

## 인증서 검증 이후에는 어떤과정이 있어?

이제 키 교환과정으로 넘어가

## API서버와 클라이언트를 기준으로 TLS연결과정을 알고싶어

클라이언트가 요청을 보내면 TLS세션을 맺게돼

1. 먼저 클라이언트가 API 서버로 TLS 연결을 보내 그게 ClientHello야
   그러면 지원하는 프로토콜, 암호목록, 랜덤값, 호스트명, HTTP/version 등을 보내

2. 그럼 서버가 응답하면서 TLS옵션을 확정해 ServerHello
   음 그러면 프로토콜 이거고 암호 이걸로하고 서버키 공유값 이거고 랜덤값 이걸로 가자

3. 클라이언트 와 서버가 서로 주고받은 값을 이용해서 세션 대칭키를 계산해

4. 클라이언트가 서버에게 합의한 세션키로 verify_data 라는걸 만들어 이거는 지금까지 오고간 메시지를 해시값에 합의된 세션키 기반으로 만든거야

## 틀리면 어떻게 돼?

틀리면 검증 실패로 종료되어버려.. 이런 상황이 생기면 TLS세션이 성립되지 않는거지

## 그 다음에는 잘연결되었다면?

핸드셰이크가 끝나면 세션키가 합의가 되잖아?

그럼 이제 평문으로 보내지않고 암호화 해서 보내는거야

## 아니 그러면 핸드셰이크때 보이면 어째?? 중간에 가로채면 되잖아

맞아 그 가로채는거 어렵지 않아 근데 문제는 세션키는 이걸로 알수가 없어 왜냐면 클라이언트와 서버가 각각 프라이빗키를 가지고 있고 그걸 조합해야 세션키가 나오는거거든

중간에 클라이언트가 전달한 수학적으로 변환된 값 그리고 서버가 전달한 수학적으로 변환된값을 보았더라도 불가능한 이유는

잘봐

클라이언트 입장에서 a 라는 난수를 발생시키고 G와 스칼라곱을 해서 aG를 만들어
클라이언트가 aG를 서버에게 보냈지??

## 응 맞아

그럼 가로채는 사람은 aG를 봤겠지 근데 왜 불가능하냐면 이 스칼라곱은 단방향성질때문에 역산이 불가능하기 때문이야

서버는 bG를 클라이언트에게 보냈지??

## 그럼 가로챈사람 마찬가지로 알수가 없잖아?? 역산을 못하니까

그치 그럼 이제 클라이언트는 자기 값 a x (b x G) =>abG
서버는 b x (a x G) = abG

이제 서로의 공통의 비밀이 생긴거고 그걸 바탕으로 암호화를 시작하는거야

## 서로 비밀값을 알게되었으니까 그 다음은 어떻게 주고받아??

그러면 이제 서로의 비밀값을 또 다시 키 파생함수에 돌려서 랜덤값으로 바꿔

## 그냥 쓰면되는거 아니야..?

그대로 쓰기에는 위험한게 구조가 일정해서 패턴도 드러나고 암호화과정에서 쓸 다른 값들도 많으니까~

## 인증서는 왜 있는거야 그럼? 이렇게 안전한 세션키가 있는데

세션키는 둘이 똑같이 만들 수는 있어

하지만 문제는 “내가 지금 진짜 네이버랑 대화 중인지” 확인을 못해

중간에 나쁜 놈이 끼어서 “나도 열쇠 하나 줄게~” 하고 속일 수 있어

> 그러면 나는 걔랑 비밀을 만들고, 걔는 또 서버랑 비밀을 만들고…
> 결국 나쁜 놈이 다 들여다볼 수 있지. (이게 중간자 공격)

## 그래서 TLS 핸드쉐이크 과정을 요약해줘

구체적인 흐름

1. 너가 요청을 보냄
2. 브라우저(클라이언트)가 https://naver.com으로 접속하려고 해

3. 이때 첫 단계가 ClientHello 메시지야

4. 서버가 응답

- 네이버 API 서버는 ServerHello 메시지를 보내면서 서버 인증서를 같이 보냄
- 여기엔 서버의 공개키, 도메인 정보, CA 서명이 들어 있음

5. 브라우저가 확인

- 브라우저는 받은 인증서를 보고:
- 서명한 CA가 신뢰할 수 있는지 확인하고,
- 도메인 이름(api.naver.com)과 맞는지 확인하고, 유효기간, 위조 여부 등을 체크

6. 인증서가 통과되면

7. 이제 키 교환(ECDHE 등)을 진행하면서, 네이버 API 서버와 클라이언트가 비밀 세션키를 만들어냄

8. 공통의 비밀을 키 파생 함수(KDF)에 넣어서 실제 무결성 검증용 키(세션키) 여러 개 생성

9. Finished 메시지 교환

10. 암호화 통신 시작! 이 이후에는 우리가 쓰는 HTTP 통신으로 서로 통신
