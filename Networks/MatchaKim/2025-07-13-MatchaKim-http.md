---
date: 2025-07-13
user: MatchaKim
topic: http
---

## 먼저 Http 는 뭐야?

Http는 클라이언트와 서버 사이 통신을 위한 규약이야

## 근데 규약이 왜 있어야해?

서로 다른 시스템이 소통하려면 약속이 필요한거지 클라이언트와 서버는 여러 기술스택, 여러 환경에서 만들어진 SW잖아?

그렇기때문에 서로 소통하려는 규약이 필요한거지

그래서 시작,진행,종료를 일관성있게 처리 가능해

## 맞네 그래서 기술스택관련없이 다양한 조합으로 개발이 가능한거구나!

맞아 통신이 있어야 동적인 정보를 주고받을 수 있는거니까

## HTTP는 그럼 모양이 어떻게 생겼어?

요청 모양은 다음과 같아

> GET /index.html HTTP/1.1
> Host: www.example.com
> User-Agent: Mozilla/5.0
> Accept: text/html

답변 모양은 다음과 같고

>

```html
HTTP/1.1 200 OK Date: Sun, 13 Jul 2025 15:22:00 GMT Content-Type: text/html;
charset=UTF-8 Content-Length: 1256 Connection: keep-alive

<!DOCTYPE html>
<html>
  <head>
    <title>Index Page</title>
  </head>
  <body>
    <h1>111</h1>
    <p>222</p>
  </body>
</html>
```

응답라인을 하나씩 상세히 알려줄게

1.  첫줄은 상태라인이야
    HTTP/1.1 200 OK
    버전 코드 메시지라고 보면 돼
2.  그 다음라인은 메타데이터야
    Date: Sun, 13 Jul 2025 15:22:00 GMT
    Content-Type: text/html;charset=UTF-8
    Content-Length: 1256
    Connection: keep-alive
    Content-Type: 응답 본문의 MIME 타입 지정 (여기선 HTML 문서)
    Content-Length: 본문의 바이트 크기
    Connection: 연결을 끊을지 유지할지 (keep-alive)

## 다른건 좀 알겠는데 Connection은 뭐야?

Connection: keep-alive가 붙어 있으면, HTTP 요청이 끝나도 TCP 연결은 닫지 않고 계속 유지돼

예전에는 HTTP 요청을 한번 받고 응답하면 바로 TCP를 끊었거든? Connection:close가 그것이지 근데 이러니까 작은 리소스들 하나씩 요청할때마다 계속 TCP연결을 만들게 되니까 성능적으로 비효율적이었던거야 그래서 그걸 개선한 방법이 connection keep alive인거야

가끔 이런 메타 데이터도 같이와
Keep-Alive: timeout=5, max=100
이 의미는 5초동안 새로운 요청이 없으면 TCP를 끊겠다는거야 그리고 max는 이 연결로 최대 100번까지 요청이 가능하다는 의미인거지

## HTTP의 무상태성 (Stateles)는 무슨뜻이야?

각 요청이 독립적이고 이전 요청을 기억하지 않는다는 거야

매번 요청할때마다 이전상태를 기억하지 않으면 장점이 뭘까?

구조가 단순해지고 확장성이 좋아 서버가 기억할 정보가 없어서 리소스가 적게 필요하다는 장점이 있지

## 근데 그로인한 단점도 있겠다

맞아 사용자가 로그인 해있는데 다음요청에서 이게 누군지 몰라서 받아들일 수가 없는거지

## 그래서 쿠키, 세션, 토큰을 사용하는구나? 무상태성이라서?

맞아 쿠키, 세션, 토큰을 사용하면 사용자 상태를 유지할 수 있는거고 로그인및 인증이 가능해지는거야 해당방식에 대한 자세한 비교는 이후 글에서 다뤄볼게 오늘은 HTTP 설명이니까

## HTTP 요청을 보내고 동작하는 과정이 어떻게 돼?

1. 사용자가 브라우저에 주소를 입력해 https://www.example.com

그럼 브라우저는 다음과 같이 파싱을 해

> 프로토콜: https
> 호스트명: www.example.com
> 포트: 443 (https의 기본 포트)
> 경로: / (기본 루트 경로)

2. 이제 브라우저 캐시를 확인해 브라우저는 요청 전에 캐시에서 해당 내용 정보들을 확인하는거지

- DNS 캐시: 이 도메인의 IP를 이미 알고 있는지?
- HTTP 캐시: 이 경로의 응답을 저장해놨는지?
- 쿠키: 이 사이트에 대해 저장된 사용자 상태 정보
- 세션/로컬 스토리지 정보
- 인증 정보 (Token 등)
- HSTS: HTTPS만 허용하는 도메인인지?

2. 만약 캐시에 IP가 없으면 브라우저가 DNS에 도메인 이름의 IP를 묻는거지

3. 그럼 이제 TCP 연결을 시도해 IP 주소를 알았으니까 브라우저가 해당 IP와 연결을 시도하는거지

TCP 연결과정은 다음과 같아

- 클라이언트가 서버에게 연결을 요청해
  SYN = 1, ACK = 0, SEQ=1000

클라이언트 내부에서 TCP는 SYN_SENT 상태로 전환돼

그럼 ISN=1000으로 서버 응답을 기다려

- 서버가 클라이언트에게 요청을 받아들여 클라이언트 SEQ=1000을 ACK=1001로 확인해 이때 서버도 자기 ISN 을 생성해
  ex) SEQ = 4000
  이때 플래그는 SYN=1, ACK=1

이제 서버에서는 이러한 SYN을 수신하면 SYN_RECIEVED 상태로 전환돼 서로 요청보내고 받고 다시 보내니까 이제 한번만 더 응답이 오면 연결을 확정할 준비를 하는거야

- 클라이언트가 SYN+ ACK 를 받고 확인 응답을 보내 서버에서 SEQ4000이 왔으니까 4001로 응답해주고 자기 시퀀스는 1 증가시켜

ACK=1, SEQ=1001, ACK=4001

만약 HTTPS라면 TCP 연결 후 먼저 TLS 암호화 협상이 이루어지고, 그 위에서 HTTP 요청이 전송돼.

## 연결이 되고 아까 말한 형식으로 데이터를 주고 받으면 그게 HTTP 통신인거네?

맞아 결국 TCP 위에서 돌아가는 규약이라는게 핵심이야

## REST 원칙, HTTP, TCP/IP 의 관계가 궁금해

다른 질문에서도 자주 나오고
헷갈릴 수 있는 부분을 설명해줄게

| 계층     | 역할                                            | 예시                     |
| -------- | ----------------------------------------------- | ------------------------ |
| **REST** | 설계 원칙 (자원 중심, URI 설계, 메서드 의미 등) | /users, GET, POST        |
| **HTTP** | 통신 방식 (요청/응답, 상태코드, 헤더 등)        | GET /users HTTP/1.1      |
| **TCP**  | 전송 계층, 패킷 신뢰성 보장                     | SYN → SYN+ACK → ACK      |
| **IP**   | 주소 지정, 라우팅                               | 192.168.0.1 같은 IP 주소 |

## 최종적으로 모든 내용을 한줄로 요약하자면

> 1. 사용자는 브라우저에서 URL을 입력하고
> 2. IP를 찾은 후 TCP 연결(3-way-handshake)을 맺고
> 3. 그 위에서 HTTP로 요청/응답을 주고받으며
> 4. 이 흐름을 REST 원칙에 따라 잘 설계하면 RESTful API가 되는 거야.
