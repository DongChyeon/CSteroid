---
date: 2025-09-19
user: Roel4990
topic: 소켓과 웹소켓의 차이
---

# 🌐 네트워킹 파트: 소켓과 웹소켓의 차이

## 1. 소켓(Socket) 이란?

- **정의**: 네트워크 상에서 데이터를 송수신하기 위한 **종단점(Endpoint)**.
- 쉽게 말해, **컴퓨터가 네트워크로 대화하기 위해 여는 문** 역할을 한다.
- OS가 제공하는 네트워크 프로그래밍 인터페이스(API)이며, TCP/IP, UDP 등 다양한 프로토콜 위에서 동작한다.

👉 **예시**

- TCP 소켓: 신뢰성 있는 연결 (예: 파일 전송, 이메일)
- UDP 소켓: 빠르지만 신뢰성이 낮음 (예: 온라인 게임, 스트리밍)

---

## 2. 웹소켓(WebSocket) 이란?

- **정의**: 브라우저(클라이언트)와 서버가 **지속적으로 연결**을 유지하면서 **양방향 통신**을 가능하게 해주는 프로토콜.
- HTTP 요청/응답 모델의 한계를 극복하기 위해 만들어졌다.
- 초기에는 **HTTP 연결을 업그레이드(Upgrade Request)** 하여 웹소켓으로 전환한다.

👉 **특징**

- 연결이 유지되므로 클라이언트/서버 모두 자유롭게 메시지를 보낼 수 있음
- 실시간성이 요구되는 서비스(채팅, 주식 시세, 온라인 게임)에 최적화
- 네트워크 비용 절감 (HTTP처럼 매번 요청-응답을 열지 않아도 됨)

---

## 3. 동작 방식 비교

### 소켓 통신

1. 서버: 소켓 생성 후 포트에 바인딩 (대기 상태)
2. 클라이언트: 서버 IP/포트로 연결 시도
3. 연결 후 데이터를 송수신 (TCP는 세션 유지, UDP는 비연결)
4. 필요 시 연결 종료

### 웹소켓

1. 브라우저 → 서버: HTTP 요청 시 `Upgrade: websocket` 헤더 전송
2. 서버가 응답하면 HTTP → WebSocket 프로토콜로 업그레이드
3. 이후 **지속 연결**을 유지하면서 양방향 데이터 송수신
4. 종료 시 클라이언트/서버가 연결을 닫음

---

## 4. 특징 차이

- **소켓**
    - OS 수준의 저수준 네트워크 인터페이스
    - 프로그래머가 TCP/UDP 프로토콜 세부 구현까지 제어 가능
    - 다양한 언어와 환경에서 사용 (C, Java, Python 등)
- **웹소켓**
    - 응용 계층의 고수준 프로토콜
    - 주로 **웹 환경**(브라우저 ↔ 서버)에서 실시간 통신을 위해 설계됨
    - HTTP와 호환 (방화벽/프록시 우회 가능)

---

## 5. 활용 사례

- **소켓**
    - 게임 서버 (UDP 기반 실시간 전송)
    - 파일 전송 (FTP, TCP 기반)
    - 원격 제어 (Telnet, SSH)
- **웹소켓**
    - 웹 기반 채팅 서비스
    - 실시간 주식 시세, 환율
    - 온라인 협업 도구(구글 Docs 동시 편집)
    - 실시간 알림 시스템

---

## 6. 비교 표

| 구분 | 소켓 (Socket) | 웹소켓 (WebSocket) |
| --- | --- | --- |
| 정의 | 네트워크 통신을 위한 종단점 | HTTP 업그레이드 기반 양방향 통신 프로토콜 |
| 수준 | OS 제공 인터페이스 (저수준) | 응용 계층 프로토콜 (고수준) |
| 통신 방식 | TCP/UDP 등 프로토콜 직접 사용 | 지속 연결 기반 양방향 메시지 |
| 사용 환경 | 모든 네트워크 프로그래밍 | 주로 브라우저 ↔ 서버 |
| 대표 사례 | FTP, SSH, 게임 서버 | 채팅, 주식 시세, 실시간 알림 |

---

✅ **정리**

- **소켓**은 "통신을 하기 위한 기본 도구"
- **웹소켓**은 "웹 환경에서 실시간 양방향 통신을 가능하게 하는 프로토콜"
- 즉, 웹소켓은 소켓 위에서 동작하며, 웹 친화적으로 표준화된 방식이다.

# 🗄 MongoDB 예시로 보는 소켓 vs 웹소켓

## 1. MongoDB에서의 일반 소켓 통신

- **상황**:

  클라이언트(애플리케이션)가 MongoDB 서버에 쿼리를 보낸다고 해봅시다.

- **동작**:
    1. TCP 소켓을 열고, 서버와 연결
    2. 클라이언트가 `find()` 같은 쿼리 요청 전송
    3. 서버가 결과를 계산해 응답
    4. 클라이언트는 응답을 받으면 소켓을 닫거나 다시 요청 시 새로 열 수도 있음

👉 즉, 요청/응답 단위의 통신에 가까움.

👉 **소켓은 단순히 파이프** 역할: 요청하면 주고받고 끝.

---

## 2. 웹소켓을 MongoDB에 비유하면 (MiniMongo, Meteor 구조)

- **상황**:

  Meteor 프레임워크에서는 클라이언트에 **MiniMongo** 라는 라이브러리가 있어서, 브라우저 안에 MongoDB처럼 데이터를 캐싱해둡니다.

- **동작**:
    1. 브라우저 ↔ 서버 간에 **웹소켓 연결**을 하나 열어둠
    2. 사용자가 `Tasks.find()` 같은 쿼리를 날리면, MiniMongo는 먼저 **로컬 캐시에서 즉시 조회**
    3. 동시에 서버에 웹소켓으로 구독(subscription)을 요청
    4. 서버 쪽 MongoDB 데이터가 바뀌면, 서버가 **자동으로 웹소켓을 통해 클라이언트에 push**
    5. 클라이언트 MiniMongo는 변경 사항을 즉시 반영

👉 따라서 사용자는 별도의 요청을 하지 않아도 데이터가 **실시간 동기화**됨

👉 **웹소켓은 파이프 + 실시간 알림 배달원** 역할

---

## 3. 코드 느낌 (단순화 예시)

### 소켓 기반 (전통 방식)

```jsx
// 요청 시마다 서버로 데이터 요청
const tasks = await fetch("/api/tasks");
console.log(tasks); // 최신 데이터, 하지만 요청해야만 받음

```

### 웹소켓 기반 (MiniMongo 스타일)

```jsx
// 웹소켓으로 서버와 연결된 상태
Tasks.find().observe({
  added: (doc) => console.log("새로운 데이터:", doc),
  changed: (doc) => console.log("변경됨:", doc),
  removed: (doc) => console.log("삭제됨:", doc)
});
// 서버 DB에서 바뀌면 자동 반영

```

---

## 4. 요약 비유

- **소켓** = "MongoDB에 매번 직접 쿼리 날리고 결과 받아오는 구조"
- **웹소켓** = "MiniMongo처럼 브라우저와 서버가 실시간으로 동기화되는 구조"

---

✅ 이렇게 MongoDB 예시(MiniMongo)로 보면:

- 소켓은 단순히 **데이터를 가져오는 통로**
- 웹소켓은 **데이터 흐름을 계속 유지하면서 바뀌는 즉시 전달해주는 통로**