---
date: 2025-07-03
user: MatchaKim
topic: MSA_DB
---

## MSA 환경에서는 보통 DB구성이 달라?

MSA 에서는 서비스 독립성이 중요해서 DB도 서비스 단위로 나누는게 기본 원칙이야

## 왜 ?? DB를 공유하면 안되는거야?

DB를 공유하면 모놀리식이랑 다를게 없어지거든 그래서 그래

다른서비스에 영향을 주지 않는다는 원칙이 중요한데 장애 발생시에 서비스 경계가 무너지니까

그럼 서비스끼리는 어떻게 데이터를 공유하는데??
직접 DB를 접속하면 안되고 api 호출이나 이벤트로 데이터를 가져와

## 그럼 데이터 정합성에 문제가 있겠다 FK가 있다든지 연관관계에 대해서 유효한지 처리가 까다롭겠어

맞아 그래서 결제랑 주문을 동시 처리하는 등의 상황에서 한쪽은 성공 한쪽은 실패하는 문제가 있을 수 있는거지

따라서 Saga 패턴이라는걸 쓰는데 이거는 보상 트랜잭션을 통해서 데이터 정합성을 유지해줘

- 예를 들어 쇼핑몰에서 주문을 넣을 때:
  1. 주문 서비스 → 주문 생성
  2. 결제 서비스 → 결제 처리
  3. 재고 서비스 → 재고 차감
- 이게 다 성공해야 주문 완료인데, 만약 재고 차감이 실패하면?
- 주문/결제는 이미 됐는데, 재고는 없는 이상한 상태가 되겠지.

## 그럼 SAGA는 어떻게 처리되는데??

실패시에 보상 트랜젝션을 실행해서 다시 롤백시키는거지

원래는 DB에서 트랜잭션에 대해서 보장을 해주지만 이런경우에는 까다로운거야

## 그럼 어떤 DB를 사용해??

MSA 의 장점이 기술스택과 DB종류에 종속되지 않는거거든 그래서 어떤 DBMS를 가져와서 사용해도 된다는게 큰 장점이야

이걸 폴리글랏 퍼시스턴스라고 해

## 유연한 아키텍쳐가 좋긴 하지만 MSA 구성에서는 확장이나 동시성 장애대응에 문제가 많겠다...

서비스마다 DB를 분리했어도 한서비스에 데이터가 수억건 쌓이기도 하잖아??
그래서 샤딩과 파티셔닝을 해

## 샤딩?

샤딩은 데이터를 여러 DB에 분산해서 저장하는건데
확장성이나 부하 분산에는 좋은데 단점은 조인이나 집계같은 연산이 복잡해

## 파티셔닝은?

하나의 DB 안에서 데이터를 논리적으로 나누는 방법이야
샤딩이랑 다르게 이건 하나의 DB에서 나누니까 더 간편하지

파티셔닝은 특정 파티션만 읽을 수 있어서 속도가 빨라져 그리고 오래되거나 데이터를 분류해서 담기때문에 Drop Archieve가 굉장히 용이하지

## DB에서 처리하는 거면 애플리케이션단에서 신경 쓸 필요도 없고 엄청 편하겠다! 안쓸 이유가 없지 않아?

파티션 키를 잘못 저장하면 데이터가 한쪽에 몰려서 이득이 없거나
쿼리 성능에서 오히려 파티션을 다 훑는 쿼리 사용시에 느려질 수 있어 잘못 설계 하면 오히려 단일테이블보다 못한거지

## 그럼 언제 쓰는게 좋아?

파티셔닝은 테이블이 수억건 이상일때나 특정 컬럼으로 자주 필터링 할때 그리고 오래된 데이터를 편히 관리할때 좋아

샤딩은 DB1개로는 저장 처리 한계에 닿으면 사용하는게 좋아

이거 외에도 CQRS라는 패턴도 있어

## CQRS???

CQRS는 명령과 책임을 분리한다는 뜻인데 원래 보통은 하나의 DB모델에 쓰기, 읽기를 다 처리하잖아?
근데 규모가 커지면 읽기성능 쓰기 성능을 동시에 가져가는게 어려워 그래서 각각의 쓰기 읽기 모델을 분리해서 최적화 하는거야

그러면 또 DB가 같은 내용에 대해서 두개로 나눠지네.. 정합성 문제가 있겠는데..
맞아 쓰기 모델에 데이터가 기록되고 읽기 모델에 동기화 되는 순간차가 생겨

## 그러면 문제 아니야??

사실 이런 구조는 얻는게 있으면 잃는것도 있는법이야 SNS 좋아요 같은건 조금 늦게 반영되어도 문제 없잖아??

사용성에 크게 문제가 있는게 아니면 성능과 운영을 위해서 감내하는거지

## 그럴 수 있는건가

그래서 그거에 대한 해결법이 있긴해

1. 아까 말한거 처럼 조금 늦게 반영되겠거니 하고 그냥 감내하기
2. 조회를 쓰기 모델로 우회 <-이건 중요한 데이터는 읽기 DB가 아니라 그냥 쓰기 DB에다가 조회 해버리는거야
3. 사용자 UX 보완 <- "주문이 접수되었습니다. 잠시 후 주문 내역에 반영됩니다" 같은 피드백을 줘서
   사용자가 즉시 반영을 기대하지 않게 UX적으로 풀어내기도 해

그러니까 위에 있는 DB전략들도 결국 도메인에 따라, 데이터에 따라, 사용자 패턴에 따라 달라질 수 있는거야
