---
date: 2025-07-03
user: MatchaKim
topic: DB-LOCK
---

## DB Lock 이 뭐야?

- 락은 하나의 데이터에 여러 사용자가 동시에 접근할때 일관성있는 데이터를 위해 잠금을 거는거야

## 어떤 예시가 될 수 있을까?

- 만약 티켓 판매 사이트에서 한정된 수량의 티켓을 풀었을때 여러명이 동시에 같은 데이터를 요청한다면 문제가 될 수 있겠지? 그러면 한명이 접근했을때 데이터를 잠그고 비즈니스 로직을 처리한 후에 다음 사용자의 로직을 순차적이게 진행시키면 되는거야

## 그러네 그럼 락이 없었다면 어떤 문제가 생겼을까?

- Dirty Read : 다른 로직 처리 과정에서 확정되지 않은 데이터를 읽는 문제 <- 아까 설명한 부분이야 티켓 -1 을 하지도 않은 값으로 알고 로직이 처리되는것

- Lost Update : 두 사용자가 동시에 수정해서 하나가 덮어쓰는것 <- 이것도 마지막 사용자의 값만 덮어쓰게 되는거니까 문제가 될 수 있는것

- Phanthom Read : 조회하는 사이에 다른 트랜잭션이 새로운 행을 INSERT하여 결과가 달라지는 현상 <- 결국 일관성없는 데이터로 문제가 될 수 있다는거지

## 근데 잠그는거니까 락이 성능상에는 안좋을거같아

- 그래서 락은 범위를 정해서 잠궈 예시를 보면 내가 A티켓의 관리를 위해 DB전체를 잠궜다고 생각해볼게.
  근데 이 상황에서 B티켓과는 관련 없는거잖아? 그럼 비효율적이겠지? 그래서 범위를 선택할 수 있는거지

-Row-level Lock 은 한줄만 그리고 Table-level Lock은 테이블 전체를 잠글 수 있는거지

- 동시성은 여러 사용자가 동시에 DB작업을 수행할 수 있는 능력이거든 그럼 어떤게 더 동시성이 높을까?

## Row-level 이 특정 줄만 잠그니까 동시 작업이 가능하지

- 맞아 대신 그만큼 관리하기가 어렵겠지? 그리고 락으로 인한 오버헤드도 있어, 락을 세밀하게 걸면 그만큼 락 관리 비용이 많이 드는거지 간단한 처리에는 Table level lock이 나을 수 있는거야

## 근데 관리하기가 어렵긴 하겠다 그래서 안거는 사람도 있어?

- 낙관적락/비관적락 vs 충돌 허용 구조가 있는거지

- 앞서 말한 동시에 같은 자원에대한 수정이 발생할 경우 해당 자원 접근을 막고 순차적이게 처리하는것을 비관적락이라고 부르고

- 낙관적 락은 자원을 잠그지는 않아, 커밋 시점에 버전 비교를 통해 데이터 충돌을 감지하고 방지하는 방식이야. 쓰기 시점에만 충돌을 체크하고 실패시 롤백하지.

## 그럼 낙관적 락은 문제가 생기면 문제생긴데로 데이터가 들어가는거야?

- 아니 그런건 아니고 충돌 감지를 하고 문제가 있으면 취소시켜버린다 이게 핵심이야

- 문제가 생긴대로 들어가는건 충돌 허용 구조인거지

- 그래서 낙관적락은 버전이라는게 있어 데이터를 읽고 수정하고 저장할때 다른 사람이 수정했는지 판단해야할거잖아? 그 버전이 판단 기준이 되는거지

- 스프링은 넓은 범위의 기능을 직접 구현하여 제공해주잖아? 낙관적락도 있어
  > @Version
  > private int version;

이렇게만 구현 추가해주면 알아서 낙관적락을 구현해주는거지

## 낙관적 락은 그럼 동일 자원에 대해 동시 수정이 빈번한 상황이면 에러만 계속 발생시키겠네?

- 맞아 그럼 어떤 상황에서 낙관적락을 쓰고 어떤 상황에서 비관적락을 쓰면 되겠니?

## 낙관적 락은 동일 자원에 대한 수정 충돌 가능성이 낮을 때, 비관적 락은 충돌 가능성이 높거나 데이터 일관성이 매우 중요한 경우!

## 트래픽 양이 많더라도 충돌이 없다면 낙관적 락이 유리할 수 있고, 트래픽이 적더라도 충돌이 자주 나면 비관적 락이 필요할 수 있는거지!!

- 굿 ㅎㅎ
