---
date: 2025-09-12
user: Roel4990
topic: 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까?
---

DB는 트래픽 급증 시 다음 세 가지 주요 전략을 통해 안정적인 응답과 확장성을 확보한다.

> 1. 로드 밸런싱
> 2. 캐싱
> 3. 쿼리 최적화

# 🚀 로드 밸런싱 (Load Balancing)

## 1️⃣ 개념 요약
로드_ 밸런싱은 **트래픽을 여러 서버로 나누어 처리**함으로써 **단일 서버 과부하를 방지**하고, **가용성과 응답 속도**를 높이는 기술이다.

데이터베이스 레이어에서도 로드 밸런싱은 중요한 확장 전략이다.

## 2️⃣ 방식 구분

| 방식 | 설명 | 예시 |
| --- | --- | --- |
| **애플리케이션 레벨 라운드로빈** | 애플리케이션이 직접 여러 DB 인스턴스를 번갈아 연결 | `Spring`에서 DB 라운드로빈 설정 |
| **프록시 기반** | 중간에 프록시(DB 프록시)를 두고 자동으로 트래픽 분산 | `HAProxy`, `ProxySQL`, `pgbouncer` |
| **리드/라이트 분리 (Master-Slave)** | 쓰기는 Master, 읽기는 여러 Slave로 분산 | PostgreSQL + read replica 구성 |
| **샤딩 (Sharding)** | 데이터를 기준으로 서버를 나눔 (ID, 지역, 시간 등) | 유저 ID 기준으로 DB 나누기 |

## 📌 프록시(Proxy)란?

### 1️⃣ 기본 개념

- **프록시(Proxy)** = "중간 대리인"
- 클라이언트와 서버 사이에 위치해서 **요청과 응답**을 중계하는 역할을 한다.
- 클라이언트는 실제 서버를 직접 알지 못해도 프록시를 통해 통신할 수 있다.

### 2️⃣ 예시 시나리오

- 스타트업에서 사용자가 늘면서 DB read 요청이 폭증 → **프록시를 통해 read 요청을 슬레이브 DB 3대로 분산**
- 특정 쿼리(INSERT/UPDATE)는 자동으로 Master로만 보내도록 설정

### 3️⃣ Master/Slave 가 뭐지?
프록시는 애플리케이션과 DB 사이에서 쿼리의 종류를 자동으로 판별한다.

INSERT, UPDATE, DELETE 같은 쓰기 쿼리 → Master DB로 전달

SELECT 같은 읽기 쿼리 → Slave DB 중 하나로 분산

그래서 Master 하나에만 쓰기를 집중시키고, Slave 여러 대에 읽기를 분산 → 부하 분산 효과

> 프록시는 클라이언트와 DB 사이의 중간 관리자 역할을 하며,
>
> 트래픽 분산(로드 밸런싱), 연결 최적화, 장애 대응을 담당한다.
>
> 즉, “DB를 더 똑똑하게 쓰도록 도와주는 중간층”이라고 생각하면 됩니다.


## 📊 언제 어떻게 쓰면 될까?

### 1️⃣ **리드/라이트 분리 (Master-Slave, Read/Write Splitting)** ✅ 가장 흔함

- **이유**: 대부분의 서비스는 "읽기 요청"이 압도적으로 많음 → 레플리카(Replica)로 분산하는 방식이 가장 쉽고 효과적
- **사례**: AWS RDS, Aurora 같은 매니지드 DB는 자동으로 리드 레플리카 지원
- **SNS, 커머스, 뉴스 서비스** 등에서 거의 표준처럼 사용

---

### 2️⃣ **프록시 기반 분산 (ProxySQL, HAProxy, pgbouncer)** 🔥 대규모 서비스에서 필수

- **이유**:
    - 애플리케이션이 복잡한 분산 로직을 몰라도 됨 (프록시가 자동 처리)
    - 장애 감지, 연결 풀링, 쿼리 라우팅까지 자동화
- **사례**:
    - MySQL → ProxySQL
    - PostgreSQL → pgbouncer + HAProxy
- 보통 **리드/라이트 분리 + 프록시 조합**으로 많이 씀

---

### 3️⃣ **샤딩 (Sharding)** 🚀 초대규모에서만

- **이유**:
    - 데이터가 한 DB 서버 용량을 초과할 때 필수
    - 설계 난이도가 높아서 초반부터 도입하는 경우는 드묾
- **사례**: 트위터, 인스타그램, 유튜브 같은 **수억 유저 규모 서비스**
- 일반 스타트업 단계에서는 잘 안 씀, **DB 수직 확장 → 레플리카 → 프록시 → 마지막에 샤딩** 순으로 발전

---

### 4️⃣ **애플리케이션 레벨 라운드로빈** 🛠️ 드물게 사용

- **이유**: 구현이 쉽지만, 장애 감지/Failover 처리 어렵고 유지보수가 힘듦
- 보통 **프록시 도입 전 임시방편**으로만 사용


> 로드 밸런싱은 “한 서버에 모든 요청이 몰리지 않도록” 트래픽을 분산시키는 핵심 전략이다.
>
> 읽기/쓰기 분리, 프록시 구성, 샤딩 등은 각 서비스 규모에 맞게 선택해야 한다.

# 💽 캐싱(Cache)

## 1️⃣ 캐싱이 뭐야?

- **캐싱(Cache)** 은 자주 사용되는 데이터를 **임시 저장소(메모리 등)에 보관**해서 DB 요청을 줄이고 성능을 높이는 기법이다.
- 목표: **DB의 부하 감소 + 응답 속도 향상**

---

## 2️⃣ 캐싱의 레벨

| 캐싱 위치 | 설명 | 예시 |
| --- | --- | --- |
| **애플리케이션 캐시** | 애플리케이션 서버 메모리에 저장 | Spring `@Cacheable`, Guava Cache |
| **분산 캐시** | 여러 서버에서 공유하는 캐시 서버 | Redis, Memcached |
| **쿼리 결과 캐시** | SQL 결과를 그대로 캐싱 | MySQL Query Cache (비추천, deprecated) |
| **페이지/뷰 캐시** | 웹 서버나 프론트에서 페이지 전체를 캐싱 | Cloudflare Cache, CDN |
| **OS / 하드웨어 캐시** | 파일시스템 캐시, 디스크 I/O 캐시 | Linux Page Cache, CPU Cache |

## 3️⃣ 캐싱 전략

- **Read-heavy 시스템**(읽기 요청이 많은 경우) → 캐싱 효과 극대화
- **Write-heavy 시스템**(쓰기 많음) → 캐시 무효화(Invalidate) 전략 중요

| 전략 | 설명 | 예시 |
| --- | --- | --- |
| **Cache-aside (Lazy loading)** | DB에서 먼저 조회 → 캐시에 저장 | 가장 흔한 방식, Redis |
| **Write-through** | 쓰기 시 캐시에도 동시에 반영 | 데이터 일관성 강화 |
| **Write-behind** | 캐시에 먼저 쓰고, 일정 시간 후 DB에 반영 | 대규모 쓰기 최적화 |
| **TTL(Time-to-Live)** | 캐시에 유효기간 설정 | 예: 5분마다 캐시 리프레시 |


# 🚬 쿼리 최적화 (Query Optimization)

## 1️⃣ 쿼리 최적화란?

- 쿼리 최적화란, **SQL이 더 빠르고 효율적으로 실행되도록 개선하는 과정**이다.
- DBMS는 내부적으로 실행 계획(Execution Plan)을 세우지만, 우리가 SQL을 어떻게 작성하느냐에 따라 성능 차이가 크게 발생한다.

---

## 2️⃣ 주요 기법

| 기법 | 설명 | 예시 |
| --- | --- | --- |
| **인덱스(Index) 활용** | 조건절에 맞는 데이터를 빠르게 찾기 위해 인덱스 사용 | `WHERE user_id = 100`에 인덱스 생성 |
| **불필요한 SELECT 줄이기** | `SELECT *` 대신 필요한 컬럼만 선택 | `SELECT name, email FROM users` |
| **Join 최적화** | 불필요한 Join 제거, Join 순서 조정 | 작은 테이블을 먼저 Join |
| **서브쿼리 대신 Join/CTE** | 중첩 서브쿼리는 느림 → Join/CTE 활용 | `WITH temp AS (...) SELECT ...` |
| **LIMIT 사용** | 대용량 결과 조회 시 페이징 처리 | `LIMIT 50 OFFSET 0` |
| **쿼리 캐싱** | 자주 쓰는 쿼리 결과는 캐시 활용 | Redis에 인기 게시글 저장 |
| **EXPLAIN 실행 계획 확인** | DBMS가 어떻게 쿼리를 실행하는지 분석 | MySQL: `EXPLAIN SELECT ...` |