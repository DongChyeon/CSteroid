---
date: 2025-11-21
user: DongChyeon
topic: 인덱스란 무엇인가?
---

## 1. 인덱스(Index)란 무엇일까?

100개의 행 중 가장 원하는 행을 찾는 방법은 무엇일까?<br>
가장 원초적인 방법은 100개의 행 모두 순차적으로 탐색하여 원하는 행을 찾는 것이다. (Full Scan)<br>

하지만, 이 방법은 비효율적이다.<br>
1부터 100까지의 숫자를 맞춰보라고 하는 게임을 떠올려보자.<br>
1부터 100까지 하나하나 물어보는 것보다  50보다 큰가요? 75보다 작은가요? 라고 물어보는게 더 빠르게 숫자를 맞출 수 있다.

DB의 인덱스도 이와 같은 방식으로 탐색 범위를 줄여주는 구조를 제공한다.

## 2. 완전 이진 탐색 트리


전체 데이터 중 절반씩 범위를 나누어 가며 탐색하기 위해 이진 탐색 트리를 사용할 수 있다.<br>
예를 들어, [20, 30, 40, 50, 60, 70, 80]에서 숫자 40을 찾는다고 가정해보자.<br>
직접 40을 찾기 위해서는 원소 전체를 탐색하여 7번의 비교가 필요하지만, 완전 이진 탐색 트리를 사용하면 3번만에 찾을 수 있다.<br>

```
        [50]
       /    \
    [30]    [70]
    / \      / \
[20] [40] [60] [80]
```

1. 루트 노드인 50과 비교한다. 40은 50보다 작으므로 왼쪽 서브트리로 이동한다.
2. 현재 노드인 30과 비교한다. 40은 30보다 크므로 오른쪽 서브트리로 이동한다.
3. 현재 노드인 40과 비교한다. 40과 일치하므로 탐색을 종료한다.

## 3. B-Tree

앞서 얘기한 이진 탐색 트리의 특징은 각 노드가 최대 두 개의 자식 노드만 가질 수 있다는 것이다.<br>
만약 원소 갯수가 많아진다면 어떨까? 원소 갯수가 30개인 이진 탐색 트리는 다음과 같다.

```
                                      [15]
                    /                                       \
               [8]                                               [23]
          /         \                                       /             \
       [4]           [12]                                [19]              [27]
     /    \        /      \                           /       \         /       \
   [2]    [6]    [10]     [14]                     [17]      [21]     [25]     [29]
  /  \    / \    /  \     /  \                    /   \      /  \     /  \      / \
[1] [3] [5] [7] [9] [11] [13] [15]              [16] [18] [20] [22] [24] [26] [28] [30]
```

만약 숫자 9를 찾는다고 가정할 시 총 5번의 비교가 필요하다. 트리에서 비교 횟수란 트리의 높이에 비례한다.

즉, 트리의 높이를 줄이는 방법이 비교 횟수를 줄이는 방법이다.<br>
따라서, 각 노드가 여러 개의 자식 노드를 가질 수 있도록 하면 트리의 높이를 줄일 수 있다.

B-Tree는 각 노드가 여러 개의 자식 노드를 가질 수 있도록 허용하는 트리 자료구조이다.

```
                          [8 | 16 | 24]
            /                   |                     \
   [2 | 4 | 6]          [10 | 12 | 14]          [18 | 20 | 22]         [26 | 28 | 30]
    /   |    \           /   |    \             /    |     \            /    |     \
 [1]  [3]   [7]       [9]  [11]  [15]       [17]  [19]   [23]       [25]  [27]   [29]
```

한 노드에 최대 3개의 키 값과 4개의 자식 노드를 가질 수 있도록 구성한 B-Tree의 모습이다.<br>
이진 탐색 트리와 마찬가지로, 루트 노드부터 시작하여 키 값을 비교하며 자식 노드로 내려간다.<br>
트리의 높이가 낮아졌기 때문에, 비교 횟수가 줄어들게 된다.

## 4. B+Tree

B-Tree에도 단점이 존재한다. 만약 1~30 전체를 순차적으로 탐색할 시 매번 루트 노드부터 시작하여 탐색을 해야 한다.<br>
또한, 중간 노드에도 데이터가 저장되어 있어 중간노드도 일일이 방문해야 한다.

순차 탐색에 더 최적화된 자료구조가 존재하는데, 그것이 바로 B+Tree이다.

```
                         [8 | 16 | 24]
              /                |                |                \
  [1|2|3|4|5|6|7] -> [9|10|11|12|13|14|15] -> [17|18|19|20|21|22|23] -> [25|26|27|28|29|30]
```

B-Tree와 다르게 B+Tree는 리프 노드만 데이터를 저장하고, 리프들은 하나의 연결 리스트로 이어져 있다.<br>
또 중간 노드는 키 + 자식 포인터로 어느 방향으로 내려갈지만 결정한다<br>

마찬가지로 1에서 30까지 순차 탐색을 한다고 가정해볼 시 다음과 같은 과정을 거친다:

1. 루트 노드인 [8 | 16 | 24]와 비교한다. 1은 8보다 작으므로 첫 번째 자식 노드로 이동한다.
2. 자식 노드인 [1|2|3|4|5|6|7]에 도달한다. 여기서 1을 찾는다.
3. 다음 원소인 2를 찾기 위해 연결 리스트를 따라 다음 리프로 이동한다.
4. 동일한 방식으로 30까지 순차적으로 탐색한다.

또한, B+Tree는 데이터가 모두 리프에 모여 있으므로, 리프의 좌측에서 우측까지 훑기만 하면 정렬된 데이터가 그대로 나온다.<br>
따라서, `WHERE age BETWEEN 20 AND 30`과 같은 범위 검색에 유용하다.

즉, B+Tree는 순차 탐색과 범위 탐색에 더 최적화된 자료구조로 현대 RDBMS에서 인덱스는 대부분 B+Tree를 사용한다.