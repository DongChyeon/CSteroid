---
date: 2025-09-12
user: Daemon
topic: "CAP 이론과 데이터 일관성"
---

# CAP 이론과 데이터 일관성

## 1. CAP 이론 (CAP Theorem)

### 의미

- 분산 시스템에서 Consistency(일관성), Availability(가용성), Partition tolerance(분할 내성) 중 최대 2개만 동시에 보장 가능하다는 이론
- Eric Brewer가 2000년에 제안, 2002년 Seth Gilbert와 Nancy Lynch가 수학적으로 증명

### 작동 방식

1. 네트워크 분할이 발생하면 시스템은 선택을 강요받음
2. 일관성 선택 시: 모든 노드가 동기화될 때까지 응답 거부
3. 가용성 선택 시: 즉시 응답하되 데이터 불일치 허용
4. 최종적으로 네트워크 복구 후 일관성 회복 시도

### 용도

- 분산 데이터베이스 설계 시 트레이드오프 결정
    - 금융 시스템: CP 선택 (정확한 잔액 > 즉시 응답)
    - SNS 피드: AP 선택 (즉시 표시 > 완벽한 동기화)
- 모바일 앱의 오프라인 모드 설계
    - 로컬 DB 우선 저장 후 나중에 서버 동기화
- 마이크로서비스 간 데이터 일관성 전략 수립

### 장점

- 시스템 설계 시 명확한 의사결정 프레임워크 제공
    - "모든 것을 다 가질 수 없다"는 현실적 제약 인식
- 비즈니스 요구사항에 맞는 아키텍처 선택 가능
    - 도메인별로 다른 CAP 전략 적용 가능

### 단점

- 실제로는 이진 선택이 아닌 스펙트럼
    - 일관성도 여러 수준 존재 (Strong, Eventual, Weak)
- 네트워크 분할이 없을 때는 세 가지 모두 제공 가능
    - CAP는 분할 발생 시의 행동 지침
- 지나친 단순화로 인한 오해 가능성
    - PACELC 같은 확장 이론이 더 정확한 설명 제공

## 2. Consistency Models (일관성 모델)

### 의미

- 분산 시스템에서 데이터 일관성을 보장하는 다양한 수준과 방식
- Strong부터 Eventual까지 다양한 스펙트럼 존재

### 작동 방식

1. **Strong Consistency**: 모든 읽기가 가장 최근 쓰기 반환
2. **Sequential Consistency**: 작업 순서는 보장하되 실시간성 불필요
3. **Causal Consistency**: 인과관계가 있는 작업만 순서 보장
4. **Eventual Consistency**: 언젠가는 일관성 달성

### 용도

- Strong Consistency가 필요한 경우
    - 계좌 이체: 정확한 잔액 필수
    - 재고 관리: 초과 판매 방지
    - 의료 기록: 생명과 직결된 정보
- Eventual Consistency로 충분한 경우
    - 좋아요 수: 즉시 동기화 불필요
    - 조회수: 대략적인 수치로 충분
    - 추천 시스템: 완벽한 실시간성 불필요

### 장점

- 비즈니스 요구사항에 맞는 일관성 수준 선택 가능
    - 과도한 일관성은 성능 저하, 부족하면 데이터 무결성 문제
- 성능과 정확성 사이의 유연한 트레이드오프

### 단점

- 복잡한 시스템에서는 여러 일관성 모델 혼재
    - 개발자가 각 상황의 보장 수준을 정확히 이해해야 함
- 디버깅과 테스트가 어려움
    - 비결정적 동작으로 재현 어려움

## 3. Offline-First Architecture

### 의미

- 로컬 데이터베이스를 Primary로 사용하고 네트워크를 선택적으로 활용하는 설계 패턴
- 모바일 앱에서 끊김 없는 사용자 경험 제공

### 작동 방식

1. 모든 읽기/쓰기를 로컬 DB에서 먼저 수행
2. UI는 로컬 DB의 변경사항을 즉시 반영 (Optimistic Update)
3. 백그라운드에서 서버와 동기화 수행
4. 충돌 발생 시 정의된 전략으로 해결

### 용도

- 네트워크가 불안정한 환경
    - 지하철/비행기 내 사용 앱
    - 해외 로밍 시 데이터 절약
    - 시골/산간 지역 서비스
- 협업 도구나 생산성 앱
    - 노트 앱: 오프라인 작성 → 온라인 시 동기화
    - 할 일 관리: 로컬 변경 → 다른 기기와 동기화
    - 문서 편집: 실시간 협업과 오프라인 편집 병행

### 장점

- 네트워크 상태와 무관한 일관된 응답 속도
    - 로컬 DB 접근은 밀리초 단위
- 배터리 효율성 향상
    - 실시간 네트워크 통신 최소화
- 해외 로밍이나 비행기 모드에서도 사용 가능

### 단점

- 동기화 로직의 복잡성
    - 충돌 해결, 중복 제거, 순서 보장 등
- 스토리지 용량 제한
    - 모바일 기기의 제한된 저장 공간
- 데이터 신선도 문제
    - 실시간 정보가 중요한 경우 부적합

## 4. Conflict Resolution Strategies

### 의미

- 여러 노드에서 동시에 같은 데이터를 수정했을 때 일관성을 회복하는 방법
- 자동 해결부터 사용자 개입까지 다양한 전략 존재

### 작동 방식

1. **충돌 감지**: 버전 번호, 타임스탬프, 해시값으로 변경 감지
2. **충돌 분석**: 변경 내용과 컨텍스트 파악
3. **해결 규칙 적용**: 미리 정의된 전략으로 병합
4. **결과 전파**: 해결된 버전을 모든 노드에 배포

### 용도

- **Last Write Wins (LWW)**
    - 설정값, 상태 플래그
    - 사용자 프로필 정보
    - 단순한 메타데이터
- **Vector Clock / Version Vector**
    - 분산 시스템에서 인과관계 추적
    - 복잡한 워크플로우 관리
    - 다중 노드 간 동기화
- **Three-Way Merge**
    - 텍스트 문서 편집
    - 소스 코드 병합
    - 구조화된 데이터 통합

### 장점

- 자동화 가능한 충돌은 사용자 개입 없이 해결
    - 대부분의 충돌은 규칙 기반으로 처리
- 도메인별로 최적화된 전략 선택 가능
    - 금융: 모든 트랜잭션 보존
    - SNS: 최신 업데이트 우선

### 단점

- 비즈니스 로직이 복잡할수록 충돌 해결도 복잡
    - 의미론적 충돌은 자동 해결 어려움
- 데이터 손실 가능성
    - LWW는 이전 변경사항 무시
- 사용자 기대와 다른 결과 가능
    - 자동 병합이 의도와 다를 수 있음

## 5. CRDT (Conflict-free Replicated Data Types)

### 의미

- 수학적으로 충돌이 발생하지 않도록 설계된 데이터 구조
- 모든 노드가 최종적으로 같은 상태로 수렴하는 것을 보장

### 작동 방식

1. **State-based CRDT (CvRDT)**: 전체 상태를 교환하고 병합
2. **Operation-based CRDT (CmRDT)**: 작업을 교환하고 적용
3. 교환법칙과 결합법칙을 만족하는 병합 함수 사용
4. 순서와 중복에 관계없이 같은 결과 보장

### 용도

- **G-Counter (Grow-only Counter)**
    - 조회수, 다운로드 수
    - 누적 통계
    - 단조 증가하는 메트릭
- **LWW-Element-Set**
    - 장바구니 관리
    - 즐겨찾기 목록
    - 태그 시스템
- **OR-Set (Observed-Remove Set)**
    - 협업 문서의 참여자 목록
    - 채팅방 멤버 관리
    - 공유 플레이리스트

### 장점

- 충돌 해결이 필요 없음
    - 설계상 충돌이 불가능
- 높은 가용성과 분할 내성
    - 네트워크 분할 중에도 각자 작업 가능
- 최종 일관성 보장
    - 모든 노드가 같은 작업을 받으면 같은 상태

### 단점

- 메모리 오버헤드
    - 메타데이터 저장으로 용량 증가
    - Tombstone이 계속 쌓임
- 제한적인 연산
    - 모든 작업이 CRDT로 표현 가능한 것은 아님
- 의미론적 의도와 불일치 가능
    - 수학적 정확성 ≠ 비즈니스 정확성

## 6. 모바일 환경의 동기화 전략

### 의미

- 모바일 기기의 특성(불안정한 네트워크, 배터리 제약, 다중 기기)을 고려한 데이터 동기화 방법
- 사용자 경험을 해치지 않으면서 데이터 일관성 유지

### 작동 방식

1. **Push-Pull 동기화**: 로컬 변경 푸시 + 서버 변경 풀
2. **Delta Sync**: 전체가 아닌 변경분만 전송
3. **Incremental Sync**: 큰 데이터를 청크로 나누어 동기화
4. **Priority-based Sync**: 중요도에 따른 순차적 동기화

### 용도

- 실시간 협업 앱
    - 문서 공동 편집
    - 화이트보드 앱
    - 프로젝트 관리 도구
- 개인 생산성 앱
    - 노트/메모 앱
    - 할 일 관리
    - 캘린더 동기화
- 미디어 중심 앱
    - 사진 백업
    - 음악 플레이리스트
    - 오프라인 비디오

### 장점

- 배터리 효율적인 동기화
    - WiFi 연결 시에만 대용량 동기화
    - 배치 처리로 웨이크업 최소화
- 사용자 투명성
    - 백그라운드에서 자동 처리
    - 충돌 시에만 사용자 개입 요청

### 단점

- 복잡한 상태 관리
    - 동기화 중/완료/실패 상태 추적
    - 부분 동기화 상태 처리
- 테스트의 어려움
    - 네트워크 상태 시뮬레이션
    - 동시성 문제 재현

## 7. 실전 고려사항

### 동기화 최적화

- **Batch Operations**: 개별 요청 대신 묶어서 처리
- **Compression**: 데이터 압축으로 네트워크 사용량 감소
- **Selective Sync**: 사용자가 필요한 데이터만 선택적 동기화
- **Smart Retry**: 지수 백오프와 지터를 활용한 재시도

### 충돌 최소화

- **Field-level Merge**: 엔티티 전체가 아닌 필드 단위 병합
- **Operational Transform**: 작업 단위로 변환하여 충돌 감소
- **Pessimistic Locking**: 중요한 작업은 락으로 보호
- **Conflict-free Design**: 가능한 CRDT 활용

### 사용자 경험

- **Optimistic UI**: 즉각적인 피드백 제공
- **Sync Status Indicator**: 동기화 상태 시각화
- **Conflict Resolution UI**: 사용자 친화적인 충돌 해결 인터페이스
- **Offline Capability Notice**: 오프라인 기능 명확히 안내
