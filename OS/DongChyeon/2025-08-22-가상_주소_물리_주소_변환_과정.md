---
date: 2025-08-22
user: DongChyeon
topic: 가상 주소 -> 물리 주소 변환 과정
---

## 가상 주소를 쓰는 이유

컴퓨터 구조 차원에서 CPU는 단순한 연산 장치이고, 메모리 접근은 오직 주소 버스를 통해 이루어진다.
만약 CPU가 물리 주소만 직접 사용한다면 다음과 같은 문제점이 있다:

1. 여러 프로세스가 동시에 실행될 때, 각자 다른 물리 메모리 영역을 강제 배치해야 하므로 주소 충돌 위험이 크다.
2. 보호 기능이 없어 사용자 프로그램이 운영체제 영역까지 접근할 수 있다.
3. 물리 메모리가 한정적이므로, 프로그램 크기가 물리 메모리를 초과할 경우 실행이 불가능하다.

따라서 CPU가 내보내는 주소는 실제 메모리에 곧바로 연결되지 않고, 가상 주소(VA) -> 물리 주소(PA) 변환 과정을 거친다. 이 변환을 담당하는 것이 MMU라는 하드웨어다.

## 가상 주소의 형식

CPU 내부의 주소 레지스터(예: 프로그램 카운터 PC, 로드/스토어 레지스터)가 만들어내는 주소는 가상 주소다.
구조적으로는 다음과 같이 나뉜다:
```
가상 주소 VA = [상위 비트: 페이지 번호(VPN)] [하위 비트: 페이지 오프셋(offset)]
```
- VPN: 상위 비트로, 어느 가상 페이지인지 식별한다
- Page Offset: 하위 비트로, 페이지 내부에서의 바이트 위치를 의미한다

물리 주소도 비슷한 구조다:
```
[물리 페이지 번호(PFN)] [오프셋]
```
여기서 Offset 비트는 변환 과정에서 그대로 전달되고, VPN -> PFN만 바뀐다.
즉, CPU가 VA를 내보내면 MMU는 상위 비트(VPN)를 해석하여 새로운 PFN을 붙이고, 그대로 하위 오프셋을 합쳐 최종 물리 주소를 만든다.

## 변환을 담당하는 하드웨어: MMU와 TLB

CPU 파이프라인 구조에서, 주소 변환은 보통 메모리 접근 단계(Memory stage)에서 수행된다. 이때 다음과 같은 하드웨어 컴포넌트가 동작한다:

1. MMU (Memory Management Unit)
  - CPU가 낸 VA를 입력받아, 페이지 테이블을 참조하여 대응하는 PA를 출력한다
  - 내부적으로 권한 비트, 유효 비트 검사도 함께 수행한다

2. TLB (Translation Lookaside Buffer)
  - MMU에 내장된 작은 고속 캐시. 최근 변환된 VPN -> PFN 매핑을 저장한다
  - TLB 히트 시: 변환이 즉시 완료 -> 파이프라인이 끊기지 않고 진행된다
  - TLB 미스 시: MMU가 페이지 테이블을 따라가며 변환 정보를 메모리에서 읽어 와야 하므로 파이프라인에 stall이 발생한다

TLB는 CPU 캐시처럼 동작하지만 주소 변환 전용 캐시이다.

## 페이지 테이블과 멀티레벨 구조

VPN -> PFN 매핑 정보는 메인 메모리에 저장된 페이지 테이블(Page Table)에 존재한다
컴퓨터 구조적으로는 루트 페이지 테이블의 물리 주소는 CPU 레지스터(예: CR3)에 저장되며, MMU는 이를 시작점으로 VPN을 여러 단계로 분할하여 탐색한다.

예를 들어 x86-64에서 48비트 가상 주소와 4KB 페이지를 사용할 경우, 가상 주소는 다음과 같이 분할된다
```
VA = [L4(9비트)][L3(9비트)][L2(9비트)][L1(9비트)][Offset(12비트)]
```
- CPU가 VA를 내보내면, MMU는 상위 9비트(L4)를 이용해 루트 테이블에서 엔트리를 찾는다
- 그 엔트리에는 다음 레벨 테이블의 물리 주소가 들어 있다
- 이를 반복하여 L1까지 내려가면 최종 PFN을 얻는다
- Offset(12비트)은 그대로 붙여 최종 PA를 형성한다

멀티레벨 구조의 가장 큰 장점은 메모리 낭비를 줄일 수 있다는 점이다
가상 주소를 L4 -> L3 -> L2 -> L1로 나누어 탐색하기 때문에, 특정 영역이 전혀 사용되지 않으면 그 하위 레벨 테이블 자체를 만들지 않아도 된다.
예를 들어 어떤 프로세스가 4GB 중 코드, 데이터, 스택 일부만 사용한다면, 실제로 접근하는 영역에 대해서만 페이지 테이블이 생성되고, 나머지 거대한 주소 공간은 테이블조차 할당되지 않는다.

또한 "보통의 경우" 4KB 기본 페이지 단위를 사용하면 반드시 L1까지 내려가야 PFN을 얻을 수 있다. 하지만 2MB 또는 1GB와 같은 큰 페이지(Huge Page)를 사용하는 경우에는 더 상위 단계(L2나 L3) 엔트리에서 바로 PFN을 가리킬 수 있으므로, 굳이 L1까지 내려가지 않고 변환을 끝낼 수 있다.

## 주소 변환의 실제 단계 (CPU 파이프라인 기준)

![Physical Memory Translation](assets/physical_memory_translation.png)

CPU가 Load 명령을 실행한다고 가정하면:
1. 주소 생성
  - ALU/주소 생성기(Address Generation Unit)가 가상 주소 VA를 만든다
2. TLB 조회
  - MMU는 VA의 VPN를 TLB에 넣어 검색한다
  - 히트 시: PFN 즉시 획득
3. 페이지 테이블 탐색 (TLB 미스 시)
  - 루트 테이블 주소(CR3 레지스터) -> L4 -> L3 -> L2 -> L1 순으로 메모리 읽기
  - 각 단계에서 DRAM 접근이 발생하므로, 4~5번의 메모리 접근이 추가될 수 있음
4. 물리 주소 조합
  - 얻은 PFN와 오프셋을 합쳐 최종 물리 주소 PA 생성
5. 캐시/메모리 접근
  - L1/L2 캐시 또는 메인 메모리 접근
6. 데이터 반환
  - Load/Store 파이프라인에 결과 전달

즉, 주소 변환은 파이프라인 내에서 캐시 접근 전에 반드시 완료되어야 한다

## 페이지 폴트 처리 (하드웨어 + 운영체제 협력)

MMU가 페이지 테이블을 탐색하는 과정에서 다음과 같은 상황이 발생할 수 있다

- Present 비트가 0인 경우: 해당 페이지가 물리 메모리에 없음
- 권한 비트 위반: 예를 들어 User 모드에서 Supervisor 영역 접근 시도

이 경우 페이지 폴트(Page Fault) 예외가 발생한다

하드웨어 동작:
1. CPU는 현재 파이프라인을 중단하고, 예외 벡터를 통해 커널 모드로 진입한다
2. 폴트가 발생한 VA, 접근 모드(Read/Write/Execute) 등을 예외 레지스터에 기록한다

운영체제 동작:
1. 페이지 폴트 핸들러가 원인을 판별한다
  - 단순 권한 위반일 경우 프로세스를 종료한다 (segmentation fault)
  - 수요 페이징이면 디스크에서 해당 페이지를 읽어 물리 프레임에 적재한다
2. 페이지 테이블을 갱신하고, 해당 VPN -> PFN 매핑을 다시 유효하게 만든다
3. CPU는 예외에서 복귀하여, 중단된 명령어를 다시 실행한다
  - 이번엔 MMU가 정상적으로 변환을 수행한다

즉, 폴트 신호는 하드웨어가 발생시키고, 해결은 운영체제가 수행하며, 둘이 협력해서 메모리 관리가 완성된다

## 운영체제 관점과의 비교

| 구분 | 컴퓨터 구조 (하드웨어)                                                | 운영체제 (소프트웨어)                                                      |
|----|--------------------------------------------------------------|-------------------------------------------------------------------|
| 역할 | CPU가 생성한 가상 주소(VA)를 물리 주소(PA)로 변환하는 기능 수행                    | 프로세스별 가상 주소 공간을 관리하고, 페이지 테이블을 생성·갱신·삭제                           |
| 주소 형식 | VA를 `[VPN \| Offset]`으로 나누어 해석, Offset은 그대로 전달하고 VPN→PFN 변환  | 페이지 단위로 메모리 자원을 할당하고 권한(읽기/쓰기/실행) 관리                              |
| MMU | 메모리 관리 장치(MMU)가 VA→PA 변환 담당                                  | MMU를 직접 제어하지 않지만, MMU가 참고할 페이지 테이블과 루트 주소(CR3 같은 레지스터)를 세팅해 줌     |
| TLB | VPN→PFN 매핑을 캐싱하여 변환 속도 향상, TLB 히트 시 즉시 변환                    | 문맥 전환 시 프로세스가 바뀌면 TLB 내용이 꼬이지 않도록 flush하거나, ASID 같은 태그를 이용해 구분 관리 |
| 페이지 테이블 | 메모리에 있는 페이지 테이블을 단계적으로 탐색해 최종 PFN을 얻음 (멀티레벨 구조)              | 페이지 테이블을 생성·해제, 권한 비트·유효 비트 관리, 페이지 교체 정책 관리                      |
| 주소 변환 과정 | 파이프라인 내에서 자동 수행 (TLB 확인 → (미스 시) 페이지 테이블 워크 → PA 완성)         | 변환 자체는 하지 않고, 페이지 테이블을 통해 하드웨어가 참고할 매핑 정보를 제공                     |
| 페이지 폴트 | PTE 유효 비트 = 0 또는 권한 위반 시 예외 신호(Page Fault) 발생, 커널 모드로 제어권 전환 | Page Fault 핸들러 실행 → 원인 판별, 디스크 I/O 수행, PTE 갱신 후 재실행               |