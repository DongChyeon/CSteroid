---
date: 2025-08-22
user: MatchaKim
topic: 데이터/스택/힙 그리고 가비지컬렉션 알고리즘
---

전역변수, 지역변수와 같은건 메모리를 얼마나 유연하게 쓸건지에 대한 문제에서 출발했어. 초창기에는 쓸 메모리를 미리 정해놓고 그대로 썼거든

# 근데 그게 어떤 문제가 있었어?

단순하고 빨랐는데, 재귀를 못썼어

# 왜?

호출 기록을 저장할 곳이 없었거든 그리고 실행중에 크기가 바뀌는 구조를 만들기가 어려웠던거지

그래서 이 문제를 해결하기 위해서

코드, 데이터, 스택, 힙

이렇게 4가지의 영역으로 구분을 하게 된거야

## 코드 영역이 뭐야?

코드 영역은 실행 할 프로그램 코드가 CPU에서 수행할 수 있게 기계어로 변환해서 저장되있는 영역이야

이부분은 컴파일 타임에 저장돼 보통 텍스트 영역이라고도 불러

## 데이터 영역은 뭐야?

전역변수와 정적변수가 저장되는 영역이야

프로그램 시작시에 할당되고 종료되면서 소멸해

## 힙영역은 뭐야?

런타임시에 결정되는 영역이야

프로그래머가 직접 공간을 할당하고 해제하는 공간이야 이 부분은 런타임에 결정되고 자바에서는 객체가 heap 영역에 생성되고 GC에 의해 정리돼

그래서 이 공간에 할당되는걸 동적할당이라고도 불러

## 스택영역은 뭐야?

호출된 함수 수행을 마치고 복귀할 주소, 데이터를 임시로 저장하는 영역이야

함수 호출시에 생성되는 지역변수, 매개변수가 저장되는 영역이고 함수가 호출이 완료되면 사라져

이 영역에서 함수 지역변수가 메모리를 초과할만큼 많아지면 스택오버플로우가 발생해

## 오버플로우에 대해서 자세히 알고싶어

오버플로우는 힙 오버플로우랑 스택 오버플로우가 있어

힙은 메모리에서 낮은주소-> 큰주소로 할당되고
스택은 큰주소-> 낮은주소로 할당되거든 그래서 각각의 영역이 침범하는경우가 있어

힙이 스택을 침범하면 힙오버플로우 스택이 힙을 침범하면 스택오버플로우야

## 그럼 스택과 힙의 차이는 명확히 뭐야?

스택은 함수호출이 끝나면 정리되는데 힙은 정리되지 않아

프로그래머가 직접 메모리를 해제해야하는데 이게 번거롭고 위험했거든

C에서는 malloc으로 할당하고 free로 해제하는데 만약 깜빡하거나 중복으로 해제하면 문제가 생기는거지

그래서 자바랑 파이썬이 주목받은것도 있어

## 왜?

이 언어들은 힙을 자동으로 관리해주니까. 그게 바로 가비지컬렉션이야

일일이 메모리 해제 안해도된다는 장점이 있는거지!

주요 GC 알고리즘에는 Mark and Sweep, Copying, Mark-Compact, Generational GC가 있어

## Mark and Sweep이 뭐야??

2가지 단계로 이루어져있는데

1. Mark 는 GC Root 에서 출발해서 따라갈 수 있는 애들은 그러니까 살아있는 객체는 전부 표시를 해

2. Sweep 단계에서는 힙 전체를 확인하면서 표시가 없는 더이상 참조 안되는 객체를 지워

장점으로는 구현이 쉽고 단순해
단점으로는 빈칸이 여기저기 생겨버려서 큰 객체를 넣기가 어려운 메모리 파편화가 발생하는거지

## 메모리 파편화가 뭔데??

메모리를 효율적이게 사용못해서 낭비가 생기는 현상이야

외부 단편화라고
아까 말한 메모리 할당을 반복하다가 보면 큰 메모리 블록이 필요한데 빈공간은 충분한테 연속된 공간이 없어서 할당 못하는 현상이고

내부 단편화라고
메모리 할당시에 필요한 크기보다 더 크게 할당되는 경우가 생겨

## 어떻게 해결해?

외부 단편화는 압축해서 메모리를 재배치하거나 빈공간을 합쳐
페이징, 세그멘테이션 기법을 사용할 수 있는거고

내부 단편화는 더 작은 단위로 블록을 관리하면 돼

## 그럼 아까 GC알고리즘으로 돌아가서 Copying은 뭐야?

1. 힙을 절반씩 두 구역으로 나눠
2. 객체는 처음에 From 영역에 들어가 그리고 GC 실행시에 To 영역으로 복사해
3. From 영역을 비워
4. From 과 To 를 역할을 바꿔서 반복해

## 복사하면서 배치하니까 파편화 문제가 없겠다

응 대신 메모리 낭비도 심하지.. 절반 메모리만 쓸 수 있으니까

## Mark-Compact 는 뭐야?

1. 아까 마크앤 스윕처럼 살아있는 객체에 표시를 해
2. 컴팩트 단계에서는 살아있는 객체들을 한쪽으로 몰아서 채워

## 이러면 파편화 문제 해결이 되긴하겠네

근데 객체를 이동시켜야하니까 이동 비용도 있는거지 ㅜ

## Generational GC는 뭐야?

핵심 아이디어는 대부분의 객체는 금방 죽는다는거야
문자열 연산할때 생기는 임시객체, 메서드 안에서 new로 만든 지역객체같이..

반면에 오래살아남는 객체는 프로그램이 끝날때까지 계속 쓰이는 경우가 많아

그래서 이둘을 분리를 한거야

## 어떻게 분리했는데?

힙을 크게 YG 와 OG로 나눠 OG 안에는 Eden 영역과 Survivor 영역으로 분리 되있어

먼저 new 키워드로 만든 객체는 Eden 영역에 넣어

그리고 Eden 이 가득차면 Minor GC를 실행하고 살아남은걸 Survivor로 복사해

그다음 또 다시 아까 말한 Minor GC가 돌면 살아남은 객체를 또다른 Survivor2 에 복사해 그래서
계속 살아남을때마다 나이가 올라가는거야

## 그리고 나이를 올린다음에는?

일정 횟수동안 살아남았으면 OG로 이동시켜 이거는 장수할거라고 판단한거지

Magor GC과정은 OG조차 가득 차면 아까 Minor GC 처럼 Major GC를 실행해

## 근데 그 구조 장점이 뭔데??

YG 에사만 빠르게 청소하니까 속도가 훨씬 빨라져 그리고 OG는 드물게 관리하니까 GC에 대한 부하를 줄일 수 있지

GC에서 가장 큰 문제가 애플리케이션이 잠깐 멈추는 Stop the world 현상이거든?

YG에서 하는 마이너 GC는 크기가 작아서 멈추는 시간도 짧다는 장점이 있는거지

알고리즘 최적화에도 유리한게 세대가 나뉘니까 서로 다른 GC 알고리즘을 최적의 조합이 가능해지는거야
