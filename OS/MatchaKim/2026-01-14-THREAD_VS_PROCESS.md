---
date: 2026-01-14
user: MatchaKim
topic: 쓰레드 vs 프로세스
---

# 프로세스가 뭐야?

운영체제로부터 자원을 할당받은 작업 단위야

# 쓰레드가 뭐야?

프로세스가 할당받은 자원을 이용하는 실행 흐름 단위야

# 프로그램은 뭐야?

exe나 dmg처럼 실행할 수 있는 파일을 정적 프로그램이라고 불러

프로그램은 단순히 코드 덩어리일 뿐인거야

# 프로세스와 프로그램의 차이는 뭔데?

프로그램이 그냥 코드덩어리 이면 프로세스는 정적인 프로그램이 동적으로 변해서 작업중인 프로그램을 의미해

모든 프로그램은 실행되기 위해서는 메모리공간이 할당되어야해

프로그램 실행순간 컴퓨터 메모리위에 올라가고 CPU를 할당받아서 우리가 이용가능한거거든

# 프로세스

과거에는 프로그램 실행할때 프로세스 하나만 사용해서 이용했어 근데 프로세스 작업 하나만 사용해서 프로그램 실행은 한계가 생긴거야

요즘에는 파일을 다운받으면서 다른 멀티 작업이 당연한데 과거에는 기다리기만 해야했어. 근데 동일 프로그램에대해 여러 프로세스를 만들면 자원이 중복할당되거든 그걸 해결하려고 스레드가 탄생했어

# 스레드는 뭔데?

하나의 프로세스에서도 여러 작업 흐름들이 있어서 크롬에서도 우리는 파일도 다운로드하면서 온라인쇼핑을 하면서 게임을 할 수 도 있는거야

# 프로세스 구조를 조금만 더 보자

프로세스 하나를 딱 찍어서 보면 안에 메모리 공간이 여러 구역으로 나뉘어 있어  
코드가 올라가는 코드 영역, 전역변수 같은 게 있는 데이터 영역, 동적으로 잡았다가 쓰는 힙(Heap), 그리고 함수 호출하면서 쌓이는 스택(Stack) 이런 식으로

그리고 OS 입장에서는 프로세스를 관리하려고 `PCB(Process Control Block)`라는 걸 따로 들고 있어  
여기 안에는 이 프로세스가 지금 어디까지 실행됐는지(레지스터 값, 프로그램 카운터), 어떤 상태인지(실행중, 대기중), 어떤 자원들 쓰고 있는지 이런 메타 정보들이 들어가

# 스레드 구조는 어떻게 다르냐면

스레드는 프로세스 안에서 돌아가는 실행 흐름이라고 했잖아  
그래서 하나의 프로세스 안에 스레드가 여러 개 있을 수 있는데, 이 친구들이 **공유하는 것**과 **각자 들고 있는 것**이 달라

- **공유하는 것**: 코드 영역, 데이터 영역, 힙, 열린 파일 디스크립터 같은 자원들
- **각자 따로 들고 있는 것**: 스택, 레지스터 값, 스레드 컨텍스트 정보들

그래서 같은 프로세스 안 스레드끼리는 전역변수나 힙에 있는 객체를 그대로 같이 건드릴 수 있어  
이게 편하긴 한데, 동시에 여러 스레드가 같은 걸 만지기 시작하면 동기화 이슈가 생기는 거지

# 멀티프로세스 vs 멀티스레드

이제 실제로 프로그램 설계할 때 많이 나오는 얘기가 멀티프로세스로 갈까 멀티스레드로 갈까야

- **멀티프로세스**

  - 프로세스끼리는 기본적으로 메모리를 안 공유해 (완전 다른 집이라고 보면 돼)
  - 그래서 한 프로세스가 죽어도 다른 프로세스는 비교적 안전해 → **안정성** 좋음
  - 대신 서로 통신하려면 IPC(파이프, 소켓, 공유 메모리 등)를 써야 해서 구조가 조금 복잡해지고 비용도 더 들어

- **멀티스레드**
  - 같은 프로세스 안에서 스레드 여러 개가 돌아가니까 메모리 공유가 자연스러워
  - 문맥 전환 비용도 프로세스끼리 바꾸는 것보다 더 싸고, 자원도 덜 먹어 → **효율** 좋음
  - 대신 하나의 스레드가 메모리 잘못 건드리거나 데드락 걸리면 프로세스 전체가 같이 위험해져

그래서 크롬 같은 브라우저도 탭을 아예 프로세스로 분리해서 안정성을 챙기고,  
각 프로세스 안에서는 또 스레드를 활용해서 효율을 올리는 식으로 섞어서 써

# 문맥 전환(Context Switching)은 뭐야?

CPU는 사실 한 번에 한 작업(한 스레드/프로세스)만 제대로 실행할 수 있는데,  
우리가 보기에는 여러 가지가 동시에 돌아가는 것처럼 느껴지잖아?  
이게 바로 문맥 전환 덕분이야

문맥 전환이란 간단히 말하면

> 지금 실행하던 애의 상태를 저장해 두고,  
> 다른 애의 상태를 다시 불러와서 이어서 실행하는 것

여기서 저장/복원하는 상태가 아까 말한 레지스터 값, 프로그램 카운터 같은 것들이고  
프로세스끼리 바꿀 때가 스레드끼리 바꿀 때보다 더 비싸  
왜냐면 메모리 맵, 캐시 같은 것도 더 크게 갈아엎어야 해서

그래서 OS 입장에서는 너무 자주 문맥 전환이 일어나도 오버헤드가 커지고,  
너무 안 바꿔줘도 특정 작업만 계속 CPU를 차지하게 되니까 적당히 스케줄링을 조절하는 거야

# 멀티코어, 동시성, 병렬성

예전에는 코어가 하나라서 진짜로는 한 번에 하나만 실행하고 빠르게 번갈아가면서 돌리는 **동시성(concurrency)** 위주였는데,  
지금은 코어가 여러 개라서 진짜로 물리적으로 동시에 여러 일을 하는 **병렬성(parallelism)**도 가능해졌어

- **동시성**: 실제로는 한 번에 하나씩 처리하지만, 빠르게 번갈아 해서 동시에 하는 것처럼 보이게 만드는 것
- **병렬성**: 물리적으로 코어 여러 개가 있어서 진짜로 동시에 여러 일을 처리하는 것

스레드는 특히 멀티코어 시대에 코어를 더 잘 활용하기 위해 등장한 개념이라고 봐도 돼  
하지만 동시성 이슈는 코어 하나만 있어도 이미 발생한다는 거 잊으면 안 돼 (번갈아가면서 같은 메모리에 접근해도 꼬일 수 있으니까)

# 스레드의 진짜 문제: 공유 자원과 동기화

스레드가 좋은 이유는 자원을 쉽게 공유해서 데이터 주고받기가 편하다는 건데  
이게 동시에 가장 큰 문제를 만든다

예를 들어서 은행 계좌 잔고를 업데이트 하는 코드가 있다고 해보자  
두 스레드가 동시에 같은 계좌 잔고를 읽고, 둘 다 더해서 저장해버리면 중간 업데이트가 날라갈 수 있어 (race condition)

그래서 이런 걸 막으려고

- 뮤텍스(Mutex)
- 세마포어(Semaphore)
- 락(lock)과 모니터(monitor)

같은 동기화 도구들을 쓰는 거야  
하지만 락도 잘못 쓰면 데드락(서로 서로 기다리다가 영원히 안 끝나는 상황)이 터져서 프로그램이 멈춰버릴 수 있어

정리하면

- 스레드는 **공유** 때문에 편하고 빠르지만
- 그 공유 때문에 **동기화 이슈**라는 새로운 난이도가 생긴다

# 언제 프로세스를 쓰고 언제 스레드를 써?

대략 이런 기준으로 생각하면 좋아

- **프로세스가 더 나은 경우**

  - 서로 완전히 분리된 서비스, 한쪽이 죽어도 다른 쪽은 안전해야 할 때
  - 보안적으로 메모리를 확실히 분리하고 싶을 때
  - 서버에서 서로 다른 역할을 하는 큰 단위 서비스를 나눌 때 (마이크로서비스 구조 등)

- **스레드가 더 나은 경우**
  - 같은 데이터/자원을 공유하면서 여러 작업을 쪼개서 병렬 처리하고 싶을 때
  - UI 스레드 + 백그라운드 작업 스레드처럼, 하나의 프로그램 안에서 역할을 나누고 싶을 때
  - I/O 기다리는 동안 다른 일을 시키고 싶을 때 (예: 네트워크 요청 여러 개 동시에)

실제 서비스에서는 둘 중 하나만 쓰기보다는  
**프로세스로 큰 덩어리를 나누고, 내부에서 스레드/이벤트 루프 등으로 세부 동시성을 관리하는 식**으로 섞어서 쓰는 경우가 많아

# 한 줄로 마무리하면

- 프로그램은 그냥 코드 덩어리
- 프로세스는 그 코드가 메모리를 할당받고 실제로 돌아가는 작업 단위
- 스레드는 그 프로세스 안에서 돌아가는 실행 흐름 단위

그리고 우리는 이 기본 개념 위에 멀티프로세스, 멀티스레드, 동시성, 병렬성, 동기화 같은 개념들을 하나씩 쌓아가면 돼
