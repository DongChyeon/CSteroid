---
date: 2025-09-05
user: MatchaKim
topic: 작은 OS JVM
---

## 자바는 왜 이렇게 많이 사용되는거야? 어떤 이점이 있길래??

> Write once, run anywhere

이건 자바의 슬로건이야

보통 소스코드를 개발하면 윈도우용, 리눅스용 등 실행환경에 굉장히 의존적이잖아? 근데 자바는 그런 의존적인 실행환경에서 완전히 탈피할 수 있었지

## 어떻게??

자바는 소스코드에서 바이트 코드로 컴파일 되거든

이 바이트코드가 어디서든 JVM 위에서만 있다면 호환되어서 실행가능한거야

그러니까 바이트코드 자체가 플랫폼에 독립적인거지

> JVM is like a mini Operating System

JVM은 작은 운영체제라는 말도 있을정도로 과언이 아니야

## 그럼 운영체제랑 JVM 의 각 부분을 비교해서 알려줘

먼저 프로그램 로더 인데

운영체제에서 실행파일을 시작하면 OS는 그 파일을 메모리에 올려서 실행을 준비해 이때 프로그램 로더는 프로그램 실행에 필요한 코드, 라이브러리를 메모리에 올려줘

자바는 실행파일은 없고 바이트코드(.class)가 있는데 클래스로더는 .class 파일을 필요할때 메모리에 불러와서 실행 가능하게 해줘

예시로 new Scanner()같은 코드 작성시에 Scanner 클래스 파일을 찾아서 메모리에 올리고 실행 파일을 준비해

결론적으로

프로그램로더 <-> 클래스 로더

다음으로는 OS의 보호기능 <-> Bytecode Verifier이야

## OS의 보호기능 <-> Bytecode Verifier?

운영체제는 사용자가 잘못된 행동을 못하게 막는 역할을 해주잖아?? JVM 에도 그런역할이 있어

자바 코드 실행시에 바이트코드 가 int에 String을 넣으려 한다든지 허용안된 명령어를 쓴건지 스택이 맞게 쓰인건지

안전한 실행을 위해 이런 부분들을 보호해줘

그 다음은

JVM Execution Engine <-> CPU가 명령을 실행하는 부분(명령 해석기 + 최적화)

## JVM Execution Engine <-> CPU가 명령을 실행하는 부분(명령 해석기 + 최적화) ??

자바 소스코드는 바이트 코드로 변환 되잖아? 근데 CPU가 이걸 이해 못하니까 기계어로 바꿔야 실행이 가능해

그래서 JVM의 Execution Engine은 크게 두 가지 방식이 있어

1. 인터프리터는 바이트코드를 한줄씩 읽고 실행하는데 이게 속도가 느리고

2. JIT 컴파일러는 자주실행되는 코드를 기계어로 변환해두고 그대로 실행해버려 그래서 속도가 빨라지게 하는거지

JVM 은 이걸 조합해서 최적화를 해나가는거야

OS는 CPU에서 실행될 수 있도록 기계어를 직접 실행하는데 CPU는 어셈블리 수준 명령어를 바로 이해하니까 별도 해석기가 필요없어

대신 OS는 스케쥴링을 해주지 그래서 프로세스/스레드 에서 어떤걸 CPU에 올릴지 결정해주는거야

다음은 메모리 구조야
Runtime Data Areas <-> 가상 메모리 구조

## Runtime Data Areas <-> 가상 메모리 구조?

JVM은 프로그램이 실행될때 메모리를 나눠서 관리해 대표적으로

Heap - 객체 저장, GC가 치워줌
Java Stack - 메서드 호출시 생기는 임시공간 (변수, 메서드 실행정보 가 들어감 / 끝나면 자동으로 정리됨)
Method Area - 클래스 정보, 메서드 코드 같은 공용데이터 저장 영역

OS에서도 비슷하게 프로그램 실행시에 메모리를 나눠서 관리하거든

1. Code 영역 - 프로그램 실행코드 (기계어)
2. Data 영역 - 전역변수, static 변수
3. Heap 영역 - 실행 중에 동적 생성된 데이터 (new, malloc)
4. Stack 영역 - 함수 호출시 사용되는 공간 (지역변수, 호출정보)

OS 도 프로그램을 코드, 힙, 스택으로 역할별로 구획을 나눠서 사용해

## 그럼 JVM이 OS 메모리에 관여하는건 아니네??

맞아, JVM 도 하나의 프로세스 거든. 운영체제 입장에서는 java 실행파일 하나야

그래도 OS는 각각의 역할이 있으니까 그거에 맞춰서 주기는 하지

따라서

> JVM Heap -> OS가 프로세스에 준 힙 영역에서 크게 떼어가고, 그 안에서 객체 관리해 JVM 은 내부에서 지난번에 공부했던 방식들로 관리하는거지

> Java Thread Stack -> OS가 스레드를 만들 때 스택 영역을 자동으로 떼어줌, JVM은 그 안에서 자바 메서드 실행 기록(프레임)을 쌓음

> Metaspace/DirectBuffer -> OS 네이티브 메모리(힙 외 공간)에서 따로 요청해 씀

그 다음은 Java Threads <-> OS Threads

## Java Threads <-> OS Threads??

OS의 스레드 관리는 프로세스 안에 실행 흐름 단위야

그래서 운영체제가 스레드를 만들면 그 스레드만 쓰는 스택 메모리를 할당해줘

이 스택에는 함수 호출 기록, 지역변수, 임시 데이터 같은게 들어가는거야

Java Threads는 JVM이 OS한테 스레드 하나 만들어달라고 요청하면

OS스레드랑 1대1로 매핑돼

## 어 이건 생각보다 추상화가 안되어있네??

응 OS스레드를 그대로 쓰는 구조거든 대신 자바에서 다루기 쉽게 랩핑 해놓은거지

원래는 스레드를 만들려면 시스템콜 불러서 복잡하게 해야하잖아? 자바는 스레드를 객체로 다룰 수 있게 해줘

또 스레드가 동시에 같은 데이터에 접근하면 충돌이 발생하잖아??

자바는 synchronized 키워드 하나로 OS에서 뮤텍스 같은걸 자동으로 써주는거지

전체적으로 정리하자면

| JVM                                           | OS                                         | 비슷한 점                                                       |
| --------------------------------------------- | ------------------------------------------ | --------------------------------------------------------------- |
| ClassLoader                                   | 프로그램 로더                              | 실행할 클래스(.class) / 실행 파일을 메모리에 올려 실행 준비     |
| Bytecode Verifier                             | 보호 기능                                  | 잘못된 코드 실행을 막고, 안전한 실행 보장                       |
| Execution Engine (인터프리터 + JIT)           | CPU 실행 + 스케줄러                        | 명령어(바이트코드 ↔ 기계어) 실행, 실행 흐름 관리                |
| Runtime Data Areas (Heap, Stack, Method Area) | 가상 메모리 구조 (Code, Data, Heap, Stack) | 실행 시 메모리를 역할별로 나눠 관리                             |
| JVM Heap                                      | OS 힙                                      | 동적으로 생성된 데이터 저장                                     |
| Java Stack                                    | OS 스택                                    | 메서드 호출 정보, 지역변수 저장                                 |
| Metaspace / DirectBuffer                      | 네이티브 메모리                            | 클래스 정보, 직접 할당 메모리 관리                              |
| Java Threads                                  | OS Threads                                 | 실행 흐름 단위, 1:1 매핑, 스케줄링은 OS가 담당                  |
| Exception Handling                            | 인터럽트 / 시그널                          | 오류 발생 시 처리: OS는 강제 종료, JVM은 예외 객체로 catch 가능 |
