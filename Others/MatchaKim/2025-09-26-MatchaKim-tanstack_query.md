---
date: 2025-09-26
user: MatchaKim
topic: tanstack_query
---

## tanstack query 가 뭐야?

react query와 같은 라이브러리인데 안쓰이는 회사가 없을정도로 서버 상태를 가져오고 캐싱하고 동기화하고 업데이트 시켜주는 편리한 친구야

## 왜 탄생한건데??

서버에 있는 데이터의 문제가 뭐라고 생각해?

1. 너가 통제할 수 없어 소유할 수 도 없고
2. 가져오고 업데이트 하는데 비동기 API가 필요해
3. 데이터를 제대로 관리하지 않으면 오래된 상태를 갖게 될 수 있어

혹시 서버에서 데이터 가져올때 문제가 뭐가있었어?

## 캐싱??

맞아 사실 캐싱은 중요한데 정말 어려운 부분이야

또 보자면 동일한 데이터를 여러번 중복으로 보내기도 하고

백그라운드에서 오래된 데이터가 계속 유지되기도 하고

이게 얼마나 오래된 데이터인지 알기도 힘들지 않았어??

그리고 받아온데이터를 어디서나 쓰고싶기도 했고..

탄스택쿼리는 이 모든 문제를 해결한 라이브러리 인거지

쉽고 빠르게 관리하고 유지하면서 몇줄만에 복잡한 코드를 유지보수성까지 챙길 수 있는 대단한 라이브러리야

이제 왜 필요한지는 알겠지??

## 응 알겠다 어떤 기능을 제공하는지 궁금해

Tanstack query는 3가지 메인 컨셉야

- Queries
- Mutations
- Query Invalidation

## 가장 먼저 쿼리가 뭐야??

서버에서 데이터 가져올때 너 이거 불편하지 않았어?

가져오는 중인지, 에러가 발생했는지, 어떤 에러인지 이러한 상황을 보통 우리가 웹페이지나 앱에따라서 보여줘야 하잖아?? 그런 데이터를 따로 선언하지 않고 이용이 가능해

그래서 API를 호출할때 단편적이게가 아니라 isPending, isError, data, error 상태를 볼 수 있는거지

이것도 좋은데 사실 여기에서 가장 중요한건 쿼리키야

## 쿼리키가 뭐야?

쿼리키는 쿼리를 캐싱하고 공유하는데에 사용되거든

쿼리키 선언은 다음과 같아

useQuery({ queryKey: ['querykey', 'querykey2'], ... })

쿼리키는 쿼리함수에서 종속적인 역할을 해서 쿼리키에 따라서 캐싱이 되고 그 내부에 변수가 변경될때마다 다시 fetch가 돼

useQuery({ queryKey: ['board', {boardId}] })

이렇게 있다고 쳐볼게

만약 어디선가
// -> /home
useQuery({ queryKey: ['board', '2'] })

이걸로 쿼리를 날린거야 근데 다른페이지에서 같은 쿼리키로 한번 이걸 더 날렸다고 가정해볼게
// -> /home/manage
useQuery({ queryKey: ['board', '2'] })

그러면 아까 보낸 쿼리의 값을 여기서도 동일하게 이용이 가능해져

## Mutation 이 뭐야?

쿼리가 읽기면 Mutation은 쓰기를 담당해

기존에는 이런 동작을 직접 axios.post처럼 호출하고 관리하기 위해서 isLoading, isError같은 플래그를 맵핑하곤 했는데 useMutation을 쓰면

그런 상태를 자동으로 제공해줘서 단순하게 관리가 가능해졌지

Mutation이 끝나면 서버 데이터가 바뀔테니까 화면에 캐시도 갱신해야하잖아?

그래서 그런 부분을 자동화 하기 위해서 Query Invalidation이라는 개념이 있는데 게시글을 추가하면 ['board'] 키 쿼리에 대한 데이터를 Query Invalidation 시키는거야

## Query Invalidation이 뭐야?

Mutation으로 서버의 데이터가 바뀌면, 클라이언트에 캐싱된 데이터는 더 이상 최신이 아닐 수 있어.
이럴 때 Query Invalidation을 사용해서 캐시를 무효화하면, React Query가 해당 데이터를 다시 refetch해서 최신 상태를 보장해줘

만약 서버 데이터가 바뀐걸 내가 알고 굳이 이 데이터는 네트워크 요청을 늘리고싶지 않아 그러면 setQueryData로 쿼리에 삽입해서 데이터를 넣어줄 수 있는거지

이 장점은 화면상에는 매우빠르게 반영이 되니까 요청도 줄어들고 좋은데 대신 직접 캐시구조를 관리해야해서 복잡해 질 수 있는거지

동시성문제까지 관리해야해서 더 복잡해질 수 있으니 유의해야해

여러 데이터가 겹치거나 사용자가 많으면 데이터가 서로 달라서 틀어질 수 있으니까 말이야

내가 지금까지는 캐시를 수동으로 갱신하는 방법만 알려줬는데

이게 매번그 전략을 바꾸고, 매번 refetch하고 하면 네트워크 낭비가 생기잖아??

그래서 staleTime과 cacheTime에 대해 알아야돼

## staleTime, cacheTime??

staleTime은 캐시된 데이터가 신선하다고 간주되는 시간이야
기본값이 0 이거든? 그래서 데이터를 가져오면 바로 상한상태로 취급을 해버려.

만약 5분을 지정해두면 5분이 지나고 다음 동작이 발생하면 자동으로 refetch가 발생하는거지

동작 종류에는 다음과 같은것들이 있어

1. 컴포넌트가 다시 마운트될 때 (refetchOnMount)
2. 브라우저 창을 다시 focus할 때 (refetchOnWindowFocus)
3. 네트워크가 끊겼다가 다시 연결될 때 (refetchOnReconnect)

메인화면 staleTime을 10분으로 잡았다고 칠게?

처음 들어가고 다른페이지를 보다가 7분뒤에 다시 들어갔어 refetch 발생해 안해

## 안하지

맞아 그럼 다른페이지 보다가 최초 진입으로부터 11분뒤에 들어갔을때는?

## refetch 해오겠네

정확해 그 다음은 cacheTime이야 최신버전으로 오면서 이걸 gcTime 가비지 컬렉션 타임으로 이름을 바꿨어 근데 내가 설명할때는 cacheTime으로 설명할게

staleTime은 refetch랑 관련된거야
cacheTime은 캐시 유지 기간에 관련된거고

cacheTime은 캐시 유지기간인데 말 그대로

보통 우리가 data를 가져오는데 기존에 캐시가 있으면 기존 캐시 데이터를 보여주거든?

근데 그 캐시데이터를 얼마나 가지고 있을지를 조절하는게 cacheTime이야

기본값은 5분이고

캐시를 가지고있으면 UX를 좋게 만들 수 있다고 했잖아? 옛날 데이터를 계속 들고있을 수 있으니까?

케이스에 따라서 어떻게 UX를 가져갈 수 있는지 설명해줘볼게

1. staleTime 짧고 gcTime 길때
   → refetch는 자주 하지만 캐시는 오래 살아있어서 항상 이전 데이터 먼저 보여주고 최신화. (SWR 전략)

2. staleTime 길고 gcTime 짧을때
   → fresh 기간은 길지만 캐시가 금방 날아가서 결국 진입할 때마다 새 fetch. (Network-first처럼 동작, UX 구림)

3. staleTime 짧고 gcTime도 짧을때
   → 들어오자마자 stale + 캐시도 금방 삭제. 사실상 항상 새 fetch, 캐시 활용 거의 없음.

4. staleTime도 길고 gcTime도 길때
   → 캐시를 오래 활용하고, 필요할 때만 refetch. 가장 UX가 좋고 SWR 전략에 가까움.

## 이렇게까지 관리하는 이유는 뭐야?

보통 서비스를 개발하다보면 서버 중심적 시각으로 보게 되곤 해 서버가 데이터를 가공,저장,전달하는 주체이고, 프론트는 단순히 그 데이터를 받아서 보여주는 수동적인 소비자처럼 여겨지기도 하는데

프론트는 단순히 데이터 소비자가 아니라 사용자 경험을 직접적으로 책임지고 있고, 프론트의 최적화 전략에 따라 서버의 부하가 절반 이하로 줄어들 수도 있고, 오히려 불필요한 트래픽을 만들어 서버를 압박할 수도 있어

결국 프론트의 코드로 서비스 전체 품질에도 큰 영향을 줄 수 있는거지

그러니까 이러한 점들을 항상 인지하고 개발에 임하도록 해보자!
