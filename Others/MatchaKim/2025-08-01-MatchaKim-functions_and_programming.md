---
date: 2025-08-01
user: MatchaKim
topic: functions and programming
---

## 명령형 프로그래밍, 선언형 프로그래밍, 함수형 프로그래밍 그리고 왜 리액트가 선언형에 함수형 기반 UI인지 궁금해

하나씩 정리해보자

## 명령형 프로그래밍이 뭐야?

명령형 프로그래밍을 알려면 컴퓨터의 역사적 배경으로 가야 해.

최초의 컴퓨터는 오직 명령의 나열만 이해가 가능했어.

우리가 흔히 아는 어셈블리, 포트란, C가 그런 명령형 언어 인 셈이지.

## 명령형 언어의 특징은 뭐야?

1. 제어흐름을 직접 명시해
   if, for, while처럼 흐름을 제어하고
2. 변수값이 계속 바뀌도록 변경 가능해
3. 사이드 이펙트가 있을 수 있어.
   이건 함수 호출시에 외부 상태에 영향을 주는거지
4. 단계적으로 1. 이거해 -> 2. 그다음 이거해 하는 순차로직이야

> let sum = 0;
> for (let i = 1; i <= 10; i++) {
> sum += i;
> }
> console.log(sum);

## 이런 코드 문제가 뭔데?

코드가 커질수록 흐름을 따라가기 힘들고 전역 상태로 버그가 많아져서

병렬처리, 테스트가 어려워

## 그럼 선언형 프로그래밍에 대해 설명해줘

선언형은 프로그래머가 "어떻게"를 통제하는게 아니라 "무엇"을 원하는지에 집중해

목표를 선언 하면 내부 로직은 알아서 추상화 이게 중요해진거지

> 명령형 : A하고 A로 B하고 B로 C하자~

> 선언형 : 다 모르겠고 C상태 만들어놔

## 명령형과 선언형 내부에 있는 개념 층위가 궁금해

(올리고 사진으로 교체)
프로그래밍 패러다임
├── 명령형 (Imperative) ← "어떻게 할지"를 말하는 방식
│ ├── 절차지향 (Procedural) ← C 언어
│ └── 객체지향 (Object-Oriented) ← Java, C++, Python
└── 선언형 (Declarative) ← "무엇을 할지"를 말하는 방식
├── 함수형 (Functional) ← Haskell, Elm, JS의 map/filter
├── 논리형 (Logic) ← Prolog
└── 질의형 (Query) ← SQL

명령형에는 대표적인 절차지향 언어로 C언어

명령형을 객체단위로 추상화 한 것이 객체지향이야
대표적으로 Java, Python, C++

데이터(상태)와 메서드(동작)을 객체로 묶은거야

## 근데 자바에도 함수형 있지 않아?

맞아 명령형 기반 객체지향 언어인데, 함수형 프로그래밍 스타일도 "추가지원" 해줘

그 추가 지원하는게 람다, 스트림, 옵셔널 같은것들이야

하지만 본질은 객체지향 명령어라는 사실이 중요한거지

## 선언형에서 함수형에 대해서 설명해줘

함수형은 선언형중에서도 순수함수와 불변성을 강조한 방식이야 if,for를 안쓰고 함수조합으로 처리해

이 장점은 상태변경이 없고 사이드 이펙트가 없다는 장점이 있어

## 논리형은?

참/거짓, 조건, 규칙을 선언하면 알아서 시스템이 도출해
이건 사람이 풀 문제를 정의만 해주면 도출해주는거지

## 질의형은 뭐야?

흔히 쓰이는 SQL, GraphQL이 질의형이야 실행방법 신경안쓰고 무엇을 원하는지 쿼리하는거지

## 프론트엔드에서 선언형과 명령형에 대해 알려줘

그럼 먼저 jquery에 대해 알 필요가 있어

jquery는 DOM API가 브라우저마다 다 달랐고 비동기처리, 이벤트 바인딩이 번거러웠어 그래서

> 브라우저 호환걱정 없이 간단하게 DOM을 다루자

라는 철학으로 시작되었어

jquery는 완전 명령형 스타일이야

어디선택->언제 이벤트 바인딩-> 무슨 CSS 직접 바꿔라

아주 전형적인 명령형 스타일 이었던거지

## 근데 요즘은 왜 안쓰는거야?

document.querySelector, fetch, classList 등으로 jQuery가 하던 걸 다 할 수 있게 되었거든

그리고 선언형 UI프레임워크가 주류가 되어서 그래

## 리액트가 어떻게 해결했는지 궁금해

리액트는 버튼을 누르면 -> 상태를 바꾸고 -> 리액트가 알아서 다시 그림

따라서 사용자는 상태만 신경쓰면 UI가 알아서 따라오게 된거야

DOM을 직접 조작하는것도 아니고 상태만 제공하면 UI가 따라오니까

## 그럼 왜 리액트는 함수형 기반이야?

리액트는 컴포넌트 자체가 순수함수거든

## 순수함수가 뭔데

같은 props와 state를 넣으면 항상 같은 UI를 반환하지? 그게 순수함수야

side effect 없이 순수함수의 특성을 가지고 있는거지

그리고 useEffect를 통해서 렌더링과 관계없는 작업은 따로 분리해서 관리가 가능해졌으니까

또 리액트는 상태 시스템 자체가 불변성에 의존해

## 불변성이 뭔데

리액트는 상태가 바뀐게 중요한게 아니야 참조가 바뀌었는지가 중요해

> todos.push({ id: 1, text: "할 일" });
> setTodos(todos);

todos 라는 배열 참조는 안바뀐거잖아? 리렌더링 안해

> setTodos([...todos, { id: 1, text: "할 일" }]);

새배열 생성해서 다시 넣었지?

참조 바뀐거지?

리렌더링해.

## 함수형에서 불변성으로 연결되는 과정이 어떻게 되는거야?

함수형 철학은 다음과 같아

1. 순수 함수 지향
2. 외부 상태 접근/변경 금지
3. 불변성 (immutability) 필요

## 아니 리액트도 상태라는게 있잖아

상태 자체를 없애려는게 아니라

상태를 예측가능! 통제가능! 하게 만드는게 중요한거고

그러기 위해서 불변성과 순수함수가 중요한거야

상태를 직접 바꾸거나 외부에서 몰래 바꾸지 말고!

바꾸려면 새로운 상태를 함수형 방식으로 만들어서 쓰는게 핵심인거지

리액트는 이렇게 말하고있는거야

> “UI는 상태의 함수야.
> 너가 상태를 직접 바꾸지 않고,
> 새 상태를 나한테 주면 내가 화면을 다시 그릴게.”

리액트에서 원시값과 참조값에 대한 표도 하나 제공해줄게

| 항목                | 🟦 원시값 (Primitive)                                                  | 🟥 참조값 (Reference)                                  |
| ------------------- | ---------------------------------------------------------------------- | ------------------------------------------------------ |
| **대표 타입**       | `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint` | `object`, `array`, `function`, `Date`, `Map`, `Set` 등 |
| **저장 방식**       | **값 자체를 저장**                                                     | **메모리 주소(참조)를 저장**                           |
| **복사 방식**       | **값이 복사됨** (완전히 독립)                                          | **주소가 복사됨** (같은 대상 가리킴)                   |
| **불변성**          | 기본적으로 **불변** (값 바꿔도 독립됨)                                 | 직접 바꾸면 **같이 바뀜** (불변성 깨짐)                |
| **예시**            | `let a = 1; let b = a; b = 2;` → `a === 1` 유지됨                      | `let a = {x: 1}; let b = a; b.x = 2;` → `a.x === 2` 됨 |
| **React 상태 감지** | 값이 바뀌면 감지 쉬움 (`setCount(count + 1)`)                          | 직접 변경하면 감지 못함 → 새 참조로 교체해야 함        |
| **비교 기준**       | **값 자체를 비교** (`1 === 1` → true)                                  | **참조 주소를 비교** (`{x:1} === {x:1}` → false)       |
| **리렌더링 관점**   | 값만 바뀌면 OK (React가 바로 인식)                                     | 주소 안 바뀌면 변경 못 느껴서 UI 안 바뀜               |

## 근데 왜 불변성이 뭔데 불변성을 왜 강조하는거야?

> 한번 만든값은 절대 바뀌지 않는다
> 값을 수정하지 말고 바꾸고싶다면 새 값을 만든다는
> "데이터는 항상 읽기전용처럼" 다루자는 철학

이게 불변성이야

## 불변성이 왜 좋은데

- 상태 변화가 예측 가능해짐
- 이전상태 보존 가능
- 디버깅이 쉬워짐
- 멀티 스레드 환경에서 경쟁조건 방지

다음과 같이 장점이 많아
