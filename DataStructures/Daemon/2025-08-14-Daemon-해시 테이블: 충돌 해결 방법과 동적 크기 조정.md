---
date: 2025-08-14
user: Daemon
topic: "해시 테이블: 충돌 해결 방법과 동적 크기 조정"
---

# 해시테이블 / HashMap, ArrayMap, SparseArray 정리

## 기본 개념

### 맵(Map)

키(Key)-값(Value) 쌍을 하나의 데이터로 저장하는 자료구조입니다. 예를 들어 키 234에 "Banana", 키 382에 "Apple"을 저장하는 방식입니다.

### 해시테이블(Hash Table)

<img width="1280" height="935" alt="image" src="https://github.com/user-attachments/assets/69ffb4ab-7c5a-4fb8-93ec-30c644d85eda" />

해시 함수를 사용하여 키를 저장 위치(버킷)로 변환하고, 해당 위치에 값을 저장하는 자료구조입니다. 키를 알면 바로 저장 위치를 찾을 수 있어 일반적으로 O(1)의 시간 복잡도로 삽입, 탐색, 삭제가 가능합니다.

**장점:**

- 빠른 연산 속도 (평균 O(1))
- 키를 통한 직접 접근 가능

**단점:**

- 해시 분포가 고르지 않으면 메모리 낭비 발생
- 빈 버킷이 많이 생길 수 있음
- 안드로이드 저가형 기기(2GB 메모리)에서는 메모리 관리가 중요

## 해시 충돌 해결 방법

### 1. Separate Chaining

<img width="1280" height="882" alt="image" src="https://github.com/user-attachments/assets/0c3a3ff0-ec89-4e27-a141-0c6311ef93c5" />

동일한 버킷을 가리키는 여러 키가 있을 때, 연결 리스트 형태로 저장하는 방식입니다.

- 삽입: O(1)
- 탐색/삭제: 최악의 경우 O(N) (N은 적재량)

### 2. Open Addressing

<img width="1280" height="798" alt="image" src="https://github.com/user-attachments/assets/2f379058-e6c3-4d54-b535-d7bdc1bdff7e" />

해시 충돌 발생 시 비어있는 다른 버킷을 찾아 저장하는 방식입니다.

**탐사 방법:**

- **선형 탐사(Linear Probing)**: 순차적으로 다음 버킷 확인
- **제곱 탐사(Quadratic Probing)**: 제곱수만큼 위치 이동
- **이중 해싱(Double Hashing)**: 다른 해시 함수를 사용하여 클러스터링 방지

## 안드로이드의 자료구조

### HashMap

<img width="946" height="710" alt="image" src="https://github.com/user-attachments/assets/7aa43325-8f64-4a0e-8fbf-04ed17626bc2" />

**특징:**

- Java/Kotlin의 기본 해시테이블 구현체
- Separate Chaining 방식 사용
- Java 8부터 버킷 내 데이터가 8개 초과 시 Red-Black 트리로 변환
- 6개 이하로 감소 시 다시 연결 리스트로 변환

**설정값:**

- 기본 Capacity: 16
- 부하 계수(Load Factor): 0.75
- 13개 버킷 사용 시 Capacity가 32로 리사이징

**문제점:**

- 항상 빈 버킷이 존재하여 메모리 낭비
- 리사이징 시 재해싱 필요

### ArrayMap

<img width="402" height="492" alt="image" src="https://github.com/user-attachments/assets/00f2e987-65a6-4e50-b580-cbc4c84320a5" />

**구조:**

- 안드로이드 SDK 제공 자료구조
- 두 개의 배열 사용:
    - `mHashes`: 키의 해시코드 저장 (기본 크기 4)
    - `mArray`: 키와 값 저장 (기본 크기 8)

**특징:**

- 실제 데이터 개수만큼만 메모리 사용
- 이진 탐색 사용으로 O(log N) 시간 복잡도
- 양방향 선형 순회로 해시 충돌 해결
- System.arrayCopy()로 빠른 리사이징

**장점:**

- 메모리 효율적
- HashMap보다 빠른 리사이징

**단점:**

- 데이터가 많을수록 연산 속도 저하
- HashMap의 O(1)보다 느린 O(log N)

### SparseArray

**구조:**

- ArrayMap과 동일한 기본 구조
- 키는 항상 Primitive 타입(int)

**특징:**

- 오토 박싱 방지 설계
    - Primitive int: 4 byte
    - Wrapper Integer: 16 byte
- 키를 int로 제한하여 메모리 절약

**장점:**

- 가장 메모리 효율적
- 정수 키 사용 시 최적

## 선택 가이드

### 성능 비교

1000개 데이터 기준 100번 읽기 작업 테스트 결과:

- ArrayMap/SparseArray는 1000개 이하 데이터에서 HashMap보다 우수한 성능

### 선택 기준

**HashMap 사용:**

- 데이터가 1000개 이상
- 빠른 연산 속도가 중요
- 메모리 여유가 충분

**ArrayMap 사용:**

- 데이터가 1000개 이하
- 메모리 효율이 중요
- 객체 타입 키 필요

**SparseArray 사용:**

- 데이터가 1000개 이하
- 정수 키만 사용
- 최대한의 메모리 효율 필요

## 실제 사용 예시

```kotlin
*// 대용량 데이터*
val largeData = HashMap<String, User>()  *// 1000개 이상// 중소규모 데이터 (객체 키)*
val mediumData = ArrayMap<String, Config>()  *// 1000개 이하// 정수 키 데이터*
val intKeyData = SparseArray<View>()  *// int 키, 1000개 이하*
```

# 해시 테이블 구현 및 성능 분석

<img width="1621" height="1042" alt="image" src="https://github.com/user-attachments/assets/82a8bf64-fa55-4d2b-80c4-26616116793b" />

<img width="1371" height="1225" alt="image" src="https://github.com/user-attachments/assets/9fad812c-2bb5-4c6b-9dac-c98ca8413ed9" />

<img width="1591" height="1563" alt="image" src="https://github.com/user-attachments/assets/cbf08b17-f9c3-44d3-b42b-63fbda179112" />

## 구현된 해시 테이블 종류

### 1. Chaining (체이닝)

```kotlin
class ChainingHashTable<K, V>(initialCapacity: Int = 16) {
    private var capacity = initialCapacity
    private var size = 0
    private var buckets = Array<MutableList<Entry<K, V>>?>(capacity) { null }
    
    private data class Entry<K, V>(val key: K, var value: V)
    
    fun put(key: K, value: V) {
        if (size >= capacity * LOAD_FACTOR_THRESHOLD) {
            resize()
        }
        
        val index = getIndex(key)
        if (buckets[index] == null) {
            buckets[index] = mutableListOf()
        }
        
        val bucket = buckets[index]!!
        for (entry in bucket) {
            if (entry.key == key) {
                entry.value = value
                return
            }
        }
        
        bucket.add(Entry(key, value))
        size++
    }
}
```

**개념:** 충돌 시 같은 버킷에 연결 리스트로 저장

**테스트 결과:**

- 10,000개 데이터: 19ms 삽입, 811개 충돌
- 메모리: 3399KB (가장 많음 - 링크드 리스트 포인터 오버헤드)
- 특징: 충돌 테스트에서 100개가 모두 하나의 버킷에 체인으로 연결됨

### 2. Linear Probing (선형 탐사)

```kotlin
class LinearProbingHashTable<K, V>(initialCapacity: Int = 16) {
    private var keys = arrayOfNulls<Any?>(capacity)
    private var values = arrayOfNulls<Any?>(capacity)
    
    fun put(key: K, value: V) {
        var index = getIndex(key)
        var probeCount = 0
        
        *// 선형 탐사: 충돌 시 다음 인덱스 순차 확인*
        while (keys[index] != null && keys[index] != key) {
            index = (index + 1) % capacity
            probeCount++
        }
        
        if (keys[index] == null) size++
        keys[index] = key
        values[index] = value
        totalProbes += probeCount
    }
}
```

**개념:** 충돌 시 다음 인덱스를 순차적으로 확인 (i+1, i+2, i+3...)

**테스트 결과:**

- 10,000개 데이터: 20ms 삽입 (가장 느림)
- 평균 탐사: 2.43회 (클러스터링 문제)
- 메모리: 245KB
- 문제점: 충돌 테스트에서 평균 49.5회 탐사 필요 (심각한 클러스터링)

### 3. Quadratic Probing (이차 탐사)

```kotlin
class QuadraticProbingHashTable<K, V>(initialCapacity: Int = 17) {
    *// 소수 크기 사용*
    private val primes = intArrayOf(17, 37, 79, 163, 331, 673, 1361, 2729, 5471, 10949, 21911)
    
    fun put(key: K, value: V) {
        var index = getIndex(key)
        var i = 0
        
        *// 이차 탐사: i^2씩 증가*
        while (keys[index] != null && keys[index] != key) {
            i++
            index = (getIndex(key) + i * i) % capacity
            probeCount++
        }
        
        keys[index] = key
        values[index] = value
    }
}
```

**개념:** 충돌 시 제곱수만큼 떨어진 위치 확인 (i+1², i+2², i+3²...)

**테스트 결과:**

- 10,000개 데이터: 12ms 삽입
- 평균 탐사: 0.53회 (가장 효율적)
- 메모리: 105KB (가장 적음)
- 특징: 소수 크기 테이블 사용 (17→37→79→163...)

### 4. Double Hashing (이중 해싱)

```kotlin
class DoubleHashingHashTable<K, V>(initialCapacity: Int = 17) {
    private fun hash2(key: K): Int {
        val h = key.hashCode().absoluteValue
        return 1 + (h % (capacity - 1))  *// 두 번째 해시 함수*
    }
    
    fun put(key: K, value: V) {
        var index = getIndex(key)
        val stepSize = hash2(key)  *// 탐사 간격*
        var i = 0
        
        *// 이중 해싱: 두 번째 해시값만큼 이동*
        while (keys[index] != null && keys[index] != key) {
            i++
            index = (getIndex(key) + i * stepSize) % capacity
            probeCount++
        }
        
        keys[index] = key
        values[index] = value
    }
}
```

**개념:** 두 번째 해시 함수로 탐사 간격 결정

**테스트 결과:**

- 10,000개 데이터: 8ms 삽입 (Open Addressing 중 가장 빠름)
- 평균 탐사: 0.40회
- 메모리: 493KB
- 균형 잡힌 성능

## 동적 리사이징 테스트

```kotlin
private fun resize() {
    val oldCapacity = capacity
    val oldKeys = keys
    val oldValues = values
    
    *// 크기 2배 증가 (또는 다음 소수)*
    capacity = if (isPrime) nextPrime(capacity) else capacity * 2
    keys = arrayOfNulls(capacity)
    values = arrayOfNulls(capacity)
    size = 0
    
    *// 모든 요소 재해싱*
    for (i in oldKeys.indices) {
        if (oldKeys[i] != null) {
            put(oldKeys[i] as K, oldValues[i] as V)
        }
    }
    
    println("${javaClass.simpleName} resized: $oldCapacity -> $capacity")
}
```

**리사이징 패턴:**

- Chaining/Linear: 16 → 32 → 64 → 128 (2배씩)
- Quadratic/Double: 17 → 37 → 79 → 163 (소수 시퀀스)
- 트리거: 적재율 75% 도달 시

## 주요 분석 결과

### 성능 순위 (10,000개 데이터 기준)

**삽입 속도:**

1. Built-in HashMap: 6ms (최적화된 구현)
2. Double Hashing: 8ms
3. Quadratic Probing: 12ms
4. Chaining: 19ms
5. Linear Probing: 20ms

**메모리 효율:**

1. Quadratic Probing: 105KB
2. Linear Probing: 245KB
3. Double Hashing: 493KB
4. Built-in HashMap: 516KB
5. Chaining: 3399KB

## 결론

1. **Quadratic Probing**이 메모리와 탐사 효율에서 가장 우수
2. **Double Hashing**이 전반적으로 균형 잡힌 성능
3. **Chaining**은 구현이 간단하지만 메모리 오버헤드 큼
4. **Linear Probing**은 클러스터링 문제로 대용량에서 비효율적
5. **Built-in HashMap**은 고도로 최적화되어 실무에서 권장
