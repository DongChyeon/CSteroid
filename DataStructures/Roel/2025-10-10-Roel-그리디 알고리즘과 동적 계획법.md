---
date: 2025-10-10
user: Roel4990
topic: 그리디 알고리즘과 동적 계획법 비교
---

# 그리디 알고리즘 vs 동적 계획법: 언제 어떤 걸 써야 할까?

알고리즘 문제를 풀 때 자주 접하는 두 가지 핵심적인 문제 해결 패러다임은 그리디 알고리즘(Greedy Algorithm)과 동적 계획법(Dynamic Programming, DP)입니다. 두 방법 모두 문제를 작은 단위로 쪼개어 해결한다는 공통점이 있지만, 문제에 접근하는 방식과 최적해를 보장하는 과정에서 근본적인 차이가 있습니다.

## 1. 그리디 알고리즘 (Greedy Algorithm)

그리디 알고리즘은 "현재 상황에서 가장 좋아 보이는 선택"을 반복하여 최종 해답에 도달하는 방식입니다. 각 단계에서 하는 선택은 그 순간에는 최적이지만, 전체적으로는 최적이 아닐 수도 있습니다.

- **핵심 특징**:
    - **탐욕적 선택 속성 (Greedy Choice Property)**: 각 단계에서의 최적의 선택이 최종적으로도 최적의 해를 구성해야 합니다.
    - **최적 부분 구조 (Optimal Substructure)**: 문제의 최적해가 부분 문제의 최적해로부터 도출될 수 있습니다.
- **장점**: 구현이 간단하고, 특정 유형의 문제에서 매우 빠르게 동작합니다.
- **단점**: 항상 최적해를 보장하지는 않습니다. 그리디 선택이 전역 최적해로 이어진다는 것을 증명해야만 사용할 수 있습니다.

### 간단한 코드 예시: 거스름돈 문제

가장 적은 수의 동전으로 거스름돈을 주는 문제입니다. (단, 동전 단위가 항상 배수 관계처럼 맞아떨어지는 경우에만 그리디가 통합니다.)

```python
def coin_change(amount, coins):
    coins.sort(reverse=True)  # 가장 큰 단위의 동전부터 확인
    count = 0
    for coin in coins:
        while amount >= coin:
            amount -= coin
            count += 1
    return count

# 470원을 500, 100, 50, 10원 동전으로 거슬러주기
print(coin_change(470, [500, 100, 50, 10]))  # 결과: 6 (100원 4개, 50원 1개, 10원 2개)
```

## 2. 동적 계획법 (Dynamic Programming)

동적 계획법은 복잡한 문제를 여러 개의 중복되는 하위 문제(Overlapping Subproblems)로 나눈 뒤, 각 하위 문제의 해를 한 번만 계산하고 그 결과를 저장(Memoization)하여 재활용하는 방식입니다. 이를 통해 불필요한 계산을 줄여 효율을 높입니다.

- **핵심 특징**:
    - **중복되는 하위 문제 (Overlapping Subproblems)**: 동일한 하위 문제가 반복적으로 나타납니다.
    - **최적 부분 구조 (Optimal Substructure)**: 문제의 최적해가 부분 문제의 최적해로부터 도출될 수 있습니다.
- **장점**: 모든 경우를 체계적으로 탐색하므로 항상 최적해를 보장합니다.
- **단점**: 그리디에 비해 구현이 복잡하고, 하위 문제의 결과를 저장할 메모리 공간(보통 2차원 배열)이 추가로 필요합니다.

### 간단한 코드 예시: 피보나치 수열 (Memoization)

피보나치 수열은 `fib(n) = fib(n-1) + fib(n-2)`로, `fib(2)`나 `fib(3)` 같은 하위 문제가 계속 중복 호출됩니다.

```python
# 메모이제이션을 위한 저장 공간
memo = [None] * 100

def fibonacci(n):
    # 기본값
    if n <= 1:
        return n
    
    # 이미 계산된 값이 있다면 재사용
    if memo[n] is not None:
        return memo[n]
    
    # 계산한 적 없는 문제라면 계산 후 결과 저장
    memo[n] = fibonacci(n - 1) + fibonacci(n - 2)
    return memo[n]

print(fibonacci(10)) # 결과: 55
```

## 3. 핵심 차이점 비교

| 구분 | 그리디 알고리즘 (Greedy) | 동적 계획법 (DP) |
|---|---|---|
| **결정 방식** | 각 단계에서 **지역적 최적해**를 선택 | 모든 하위 문제의 해를 고려하여 **전역 최적해**를 결정 |
| **최적해 보장** | 보장하지 않음 (특정 조건 만족 시에만) | 항상 보장함 |
| **접근 방식** | Top-down (큰 문제에서 시작해 선택을 줄여나감) | Bottom-up (작은 문제부터 풀어 큰 문제의 해를 구축) 또는 Top-down(Memoization) |
| **핵심 속성** | 탐욕적 선택 속성 | 중복되는 하위 문제 |
| **주요 사용 사례** | 최소 신장 트리(Prim, Kruskal), 일부 거스름돈 문제 | 배낭 문제(Knapsack), 최장 공통 부분 수열(LCS), 모든 쌍 최단 경로(Floyd-Warshall) |

## 4. 결론: 언제 무엇을 써야 할까?

- **그리디 알고리즘**은 문제의 구조가 단순하고, **매 순간의 최적 선택이 최종 결과에서도 최적임이 명백할 때** 사용합니다. 직관적이고 빠른 해결책이 필요할 때 우선적으로 고려해볼 수 있습니다.

- **동적 계획법**은 문제가 복잡하고, **하위 문제들의 최적해를 조합하여 전체 문제의 최적해를 찾아야 할 때** 사용합니다. 최적해가 반드시 보장되어야 하는 상황에 적합합니다.

결국, 어떤 알고리즘을 선택할지는 **문제의 구조**에 달려있습니다. 그리디로 풀 수 있을 것 같아도 확신이 없다면, 왜 그 방법이 최적해를 보장하는지 먼저 증명하거나, 동적 계획법으로 더 안전하게 접근하는 것이 좋습니다.
