---
date: 2025-08-29
user: Ywoosang
topic: "비트 연산과 부분집합"
---

# 비트 연산과 부분집합 

## 이진법 개요

이진법은 0과 1로만 수를 표현하는 체계이다. 십진수를 이진수로 변환할 때 각 자리는 2의 거듭제곱으로 계산된다.

예:
7 = 2² + 2¹ + 2⁰ = 111₂

| 십진수 | 이진수  |
| --- | ---- |
| 0   | 0    |
| 1   | 1    |
| 2   | 10   |
| 3   | 11   |
| 4   | 100  |
| 5   | 101  |
| 6   | 110  |
| 7   | 111  |
| 8   | 1000 |

---

## 비트 연산자

### AND (`&`)

각 자리에서 둘 다 1인 자리만 1이 되고, 나머지는 0이 된다.

```java
System.out.println(6 & 3); // 2
// 6 = 110
// 3 = 011
// & = 010 => 2


// 7  = 111 
// 3  = 011
// &  = 011  => 3
```

### OR (`|`)

두 비트 중 하나라도 1이면 1을 반환한다.

```java
System.out.println(6 | 3); // 7
// 6 = 110
// 3 = 011
// | = 111 -> 7
```

### XOR (`^`)

두 비트가 다를 때 1을 반환한다.

```java
System.out.println(6 ^ 3); // 5
// 6 = 110
// 3 = 011
// ^ = 101 -> 5
```

### 왼쪽 Shift (`<<`)

비트를 왼쪽으로 이동시키고 새로 생긴 자리는 0으로 채운다. 십진수 기준으로 2배씩 커진다.

```java
System.out.println(7 << 1); // 14
System.out.println(7 << 2); // 28
```

### 오른쪽 Shift (`>>`)

비트를 오른쪽으로 이동시키고 잘린 부분은 버린다. 십진수 기준으로 2의 거듭제곱으로 나눈 몫이 된다.

```java
System.out.println(7 >> 1);  // 3
System.out.println(27 >> 2); // 6
System.out.println(415 >> 4); // 25
```

---

## 비트마스크를 활용해 부분집합 구하기

```java
public class SubsetExample {
    public static void main(String[] args) {
        String[] letters = {"a", "b", "c"};
        int n = letters.length;

        for (int i = 0; i < (1 << n); i++) { // 2^n 경우의 수
            StringBuilder selected = new StringBuilder("[");
            for (int j = 0; j < n; j++) {
                if ((i & (1 << j)) != 0) { // j번째 비트가 켜져있으면 선택
                    selected.append(letters[j]).append(" ");
                }
            }
            selected.append("]");
            System.out.println(selected);
        }
    }
}
```

출력 예시:

```
[]
[a ]
[b ]
[a b ]
[c ]
[a c ]
[b c ]
[a b c ]
```

### 예시문제 
- https://www.acmicpc.net/problem/1182

N개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수를 구하기  
N: 정수의 개수, S: 정수 (1 ≤ N ≤ 20, |S| ≤ 1,000,000)


```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) throws Exception {

        // 입출력 구성
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        int N = Integer.parseInt(st.nextToken());
        int S = Integer.parseInt(st.nextToken());

        int[] numbers = new int[N];
        
        st = new StringTokenizer(br.readLine(), " ");
        for(int i=0; i<N; i++){
            numbers[i] = Integer.parseInt(st.nextToken());
        }
        br.close();

        int cnt = 0;
        if (S == 0) {
            cnt -= 1;
        }

        // 1 ~ N 번째까지 각각 포함은 1 미포함은 0 으로 생각해 비트로 풀이함
        // 모든 경우의 수 2^20 = 1048576 
        // X 20 <= 100_000_000 (시간제한 2초 통과 가능)
        for(int i=0; i< (1 << N); i++) {
            int sum = 0;

            // 맨 뒤부터 각 자리가 1이면 포함해 sum 에 더하고 0 이면 더하지 않음
            // 예를들어 100101 이고 3번째 자리(j=2) 의 포함여부를 알려면
            // 1 << 2  100 과 & 연산을 통해 알 수 있음
            for(int j=0; j<N; j++){
                // j번째 비트가 꺼져 있으면  0
                // j번째 비트가 켜져 있으면  2^j
                if((i & (1 << j)) != 0){
                    sum += numbers[j];
                }
            }
            if(sum == S){
                cnt += 1;
            }
        }
        bw.write(String.valueOf(cnt));
        bw.flush();
        bw.close();
    }
}
```
